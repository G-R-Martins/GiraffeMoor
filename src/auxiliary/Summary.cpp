#include "PCH.h"
#include "Summary.h"
#include "MooringModel.h"
#include "Log.h"


//Global object
extern MooringModel mm;

//Constants
constexpr int SizeColumn = 10; //Columns size to print table with line summary
constexpr int precision = 6;   //Precision for doubles


Summary::Summary()
	: summ_name("")
{}

//Creates summary file 
void Summary::CreateSumFile_Impl(const std::string& name_with_folder, const std::string& version)
{
	summ_name = name_with_folder + ".sum";
	std::ofstream sum_file(summ_name, std::ios::out | std::ios::binary);
	if (!sum_file)
	{
		Log::AddWarning("The summary file could not be created.\n");
		return;
	}
	sum_file << "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n";
	sum_file << "|                                                       |\n";
	sum_file << "+     Summary file generated by GIRAFFEMoor v" << version << "     +\n";
	sum_file << "|                                                       |\n";
	sum_file << "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n";

	//Date
	std::chrono::system_clock::time_point time = std::chrono::system_clock::now();
	time_t tt = std::chrono::system_clock::to_time_t(time);

	//string with full date
	std::string today = ctime(&tt);

	std::string_view month_day(today.c_str() + 4, 6);
	std::string_view hour(today.c_str() + 11, 2);
	std::string_view minute(today.c_str() + 14, 2);
	std::string_view year(today.c_str() + 20, 4);

	sum_file << "File created on: " << month_day << ", " << year << " at " << hour << "h" << minute << "min \n\n";


	//Close file
	sum_file.close();
}

void Summary::CreateSumFile_Impl(const std::string& name_with_folder, std::string_view version)
{
	summ_name = name_with_folder + ".sum";
	std::ofstream sum_file(summ_name, std::ios::out | std::ios::binary);
	if ( !sum_file )
	{
		Log::AddWarning("The summary file could not be created.\n");
		return;
	}
	sum_file << "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n";
	sum_file << "|                                                       |\n";
	sum_file << "+     Summary file generated by GIRAFFEMoor v" << version << "     +\n";
	sum_file << "|                                                       |\n";
	sum_file << "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n";

	//Date
	std::chrono::system_clock::time_point time = std::chrono::system_clock::now();
	time_t tt = std::chrono::system_clock::to_time_t(time);

	//string with full date
	std::string today = ctime(&tt);

	std::string_view month_day(today.c_str() + 4, 6);
	std::string_view hour(today.c_str() + 11, 2);
	std::string_view minute(today.c_str() + 14, 2);
	std::string_view year(today.c_str() + 20, 4);

	sum_file << "File created on: " << month_day << ", " << year << " at " << hour << "h" << minute << "min \n\n";


	//Close file
	sum_file.close();
}

//Modifies summary file 
void Summary::Append2File_Impl()
{
	//Append to summary file
	std::ofstream sum_file(summ_name, std::ofstream::app);
	if (!sum_file.good())
	{
		Log::AddWarning("Cannot open the summary file!\n");
		return;
	}

	int cur_section = 0;

	//=======================================================================
	//Lines header
	sum_file << ++cur_section << ") Lines\n";

	for (const SummLines& line : lines)
		sum_file << line;

	//=======================================================================
	//Vessels header
	sum_file << ++cur_section << ") Vessels\n";

	//Vessel data
	for (Vessel& vessel : mm.vessel_vector)
	{
		sum_file << "\tVessel: " << vessel.GetNumber() << "\n";
		sum_file << "\t\tNode: " << vessel.GetNode() << "\n";
		sum_file << "\t\tElement: " << vessel.GetElement() << "\n";
		sum_file << "\t\tNodeSet: " << vessel.GetNodeset() << "\n\n";
	}


	//=======================================================================
	//Environment header
	sum_file << ++cur_section << ") Environment\n";

	//Environment data
	sum_file << "\tWater depth: " << mm.environment.GetWaterDepth() << "m\n";
	sum_file << "\tSea current: ";

	//Case with no sea current
	if (!mm.environment.CheckIfExistSeaCurrent())
		sum_file << "no sea current\n";
	//Case with sea current
	else
	{
		//Maximum and minumum values for the sea current speed
		double max_speed = 0.0, min_speed = 100.0;
		double value_const_seacur = 0.0;

		//Assuming sea current is constant
		mm.environment.SetBoolConstantSeaCurrent(true);
		value_const_seacur = mm.environment.GetSeaCurrent(0).speed;

		//Checks sea current actually is constant
		for (const SeaCurrent& sc : mm.environment.GetSeaCurrentVec())
		{
			if (mm.environment.CheckIfSeaCurrentIsConstant() && sc.speed != value_const_seacur)
				mm.environment.SetBoolConstantSeaCurrent(false);

			//Maximum and minimum speeds
			if (sc.speed > max_speed) max_speed = sc.speed;
			if (sc.speed < min_speed) min_speed = sc.speed;
		}

		//Print sea current summary 
		if (mm.environment.CheckIfSeaCurrentIsConstant())
			sum_file << "constant, " << mm.environment.GetSeaCurrent(0).speed << "m/s and " << mm.environment.GetSeaCurrent(0).azimuth << "deg\n";
		else
			sum_file << "between " << min_speed << "m/s and " << max_speed << "m/s\n";
	}

	//Seabead and friction data
	sum_file << "\tSeabed:\n";
	sum_file << "\t  NodeSet: " << mm.pil_node_set << '\n';
	sum_file << "\t  Friction: ";
	if (mm.environment.GetSeabed().mu)
		sum_file << "coefficient = " << mm.environment.GetSeabed().mu << "\n\n";
	else
		sum_file << "no friction\n\n";


	//=======================================================================
	//Solution header
	sum_file << ++cur_section << ") Solution steps\n";

	//Formating output
	sum_file.setf(std::ios::scientific);
	sum_file.precision(3);

	//Print steps
	for (const auto& step : steps)
	{
		static int cont_step = 0;
		sum_file << '\t' << "[" << ++cont_step << "] " << std::get<0>(step) << "s - " << std::get<1>(step) << "s : " << std::get<2>(step) << '\n';
	}
	sum_file << '\n';


	//=======================================================================
	//Check if the analytical stiffness matrix of the system was calculated
	if (mm.stiff_matrix && mm.stiff_matrix->bool_ana)
	{
	//Stiffness matrix header
		sum_file << ++cur_section << ") Analytical stiffness matrix\n";

		//Close file
		sum_file.close();

		//Check residuos and print to file
		mm.stiff_matrix->check_Ktan();
		mm.stiff_matrix->K_tan.fprint(summ_name.c_str());
	}
	else
		//Close file
		sum_file.close();
}

void Summary::AddLine_Impl(const std::array<unsigned int, 2>& nodes, const std::array<unsigned int, 2>& elements,
					  const std::array<unsigned int, 2>& nodesets, const std::array<double, 2>& tensions,
					  const unsigned int& number, const std::string_view& configuration,
					  bool TDP, const double& x_tdp, const double& total_length, const unsigned int& segs)
{
	lines.emplace_back(SummLines());
	lines.back().extremities = std::make_pair(Summary::LineExtremities({ nodes[0], elements[0], nodesets[0], tensions[0] }), Summary::LineExtremities({ nodes[1], elements[1], nodesets[1], tensions[1] }));
	lines.back().number = number;
	lines.back().config = configuration;
	lines.back().hasTDP = TDP;
	lines.back().tdp_pos = x_tdp;
	lines.back().len = total_length;
	lines.back().segs = segs;
}

std::vector<std::tuple<double, double, std::string>>& Summary::GetSteps_Impl()
{
	return steps;
}

std::ostream& operator<<(std::ostream& out, const Summary::SummLines& line)
{
//Line number
	out << "\tLine " << line.number << "\n";

//Current line data
	out << "\t\tConfiguration: " << line.config;
	if (line.hasTDP)
		out << ", with TDP at " << line.tdp_pos << "m from anchor";
	out << "\n";
	out << "\t\tTotal length: " << line.len << "m\n";
	out << "\t\tNumber of segments: " << line.segs << "\n\n";

//Formating output
	out.setf(std::ofstream::scientific);
	out.setf(std::ofstream::internal);
	//out.precision(precision);//	std::setprecision(6);
	out.fill(' ');

//Table with data	
	out << "\t         -----------------------------------------------\n";
	out << "\t        |   Element      Node   NodeSet     Tension[N]  |\n";
	out << "\t -------|-----------------------------------------------|\n";
	out << "\t| First |";
	out << std::setw(SizeColumn) << line.extremities.first.element
		<< std::setw(SizeColumn) << line.extremities.first.node
		<< std::setw(SizeColumn) << line.extremities.first.nodeset
		<< std::setw(SizeColumn + 6) << std::setprecision(precision) << line.extremities.first.tension << " |\n";
	out << "\t| Last  |";
	out << std::setw(SizeColumn) << line.extremities.second.element
		<< std::setw(SizeColumn) << line.extremities.second.node
		<< std::setw(SizeColumn) << line.extremities.second.nodeset
		<< std::setw(SizeColumn + 6) << std::setprecision(precision) << line.extremities.second.tension << " |\n"; 
	out << "\t ------------------------------------------------------- \n\n";
	
	out.unsetf(std::ofstream::scientific);

	return out;

}
