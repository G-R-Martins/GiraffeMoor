#include "PCH.h"
#include "IO.h"
// Database headers
#include "MooringModel.h"
#include "GiraffeModel.h"
#include "ExternalTimeHistory.h"
// Auxiliary namespace headers
#include "AuxFunctions.h"
#include "Log.h"

// Header file generated by CMake with some settings
#include "GiraffeMoorConfig.h"

// Global objects
extern MooringModel mm;
extern GiraffeModel gm;


namespace aux_read = AuxFunctions::Reading;


// Static variables

std::string IO::folder_name;
std::string IO::input_name;
std::string IO::name;

std::ifstream IO::s_inp;

std::string IO::version = std::to_string(GiraffeMoor_VERSION_MAJOR)
	/*-- The following option to check and introduce '0' if n < 10 is quite inefficient, but one of the shortest ways to do it --*/
	+ "." + std::string(2 - std::to_string(GiraffeMoor_VERSION_MINOR).length(), '0') + std::to_string(GiraffeMoor_VERSION_MINOR) 
	+ "." + std::string(2 - std::to_string(GiraffeMoor_VERSION_PATCH).length(), '0') + std::to_string(GiraffeMoor_VERSION_PATCH) 
	+ "a";


static MAP_FUNC s_mandatory_keys_read_func = { 
	{ "Keypoints", &IO::ReadKeypoints },
	{ "SegmentSets", &IO::ReadSegmentSets },
	{ "Lines", &IO::ReadLines },
	{ "Vessels", &IO::ReadVessels },
	{ "SegmentProperties", &IO::ReadSegmentProperties },
	{ "Environment", &IO::ReadEnvironment},
	{ "Solution", &IO::ReadSolution }
};


static MAP_FUNC s_optional_keys_read_func = { 
	{ "Monitors", &IO::ReadMonitors },
	{ "GiraffeSolver", &IO::ReadGiraffeSolver },
	{ "PostProcessing", &IO::ReadPostProcessing },
	{ "StiffnessMatrix", &IO::ReadStiffnessMatrix },
	{ "Constraints", &IO::ReadConstraints },
	{ "VesselDisplacements", &IO::ReadVesselDisplacements },
	{ "NodalLoads", &IO::ReadNodalLoads },
	{ "DisplacementFields", &IO::ReadLineDisplacementFields }
};



//Reads GiraffeMoor input file
bool IO::ReadFile()
{	
	std::cout << " ______________________________________________________________ \n";
	std::cout << "|                                                              |\n";
	std::cout << "|                        GiraffeMoor                           |\n";
	std::cout << "|               University of Sao Paulo - Brazil               |\n";
	std::cout << "|                                                              |\n";
	std::cout << "|                                                v. " << IO::version << "   |\n";
	std::cout << "|______________________________________________________________|\n\n";
	

	while (true)
	{
		if (__argc == 1)
		{
			std::cout << "Enter the name of the input file: ";
			std::getline(std::cin, input_name);

			//folder in the same location of the executable
			folder_name = "./" + input_name + "/";
		}
		//passed only the input file name (solution folder in the same location of the executable)
		else if (__argc == 2)
		{
			input_name = __argv[1];
			folder_name = input_name + "/";
		}
		//passed the folder name and the input file name
		else if (__argc == 3)
		{
			input_name = __argv[2];
			folder_name = std::string(__argv[1]) + input_name + "/";
		}
		else
		{
			std::cerr << "invalid number of arguments passed to GiraffeMoor"; 
			std::exit(EXIT_FAILURE);
		}
		name = folder_name + input_name + ".gmr";
	
		std::cout << "\n";
		
		//try to read the same location of the executable file of Giraffe
		s_inp.open(name);
		if (!s_inp.is_open())
		{
			folder_name = "C:/Users/Public/Documents/GiraffeMoor/";
			
			//checks if there isn't a 'GiraffeMoor' folder in public documents
			if (!std::filesystem::is_directory(folder_name))
				std::filesystem::create_directory(folder_name);
	
			name = folder_name + input_name + ".gmr";
			s_inp.open(name);
			if (!s_inp.is_open())
				std::cout << "Error reading the input file. Try again.\n";
			else
				break;
		}
		else
		{
			if ( __argc > 1 )
				std::cout << "Running file \"" << input_name << ".gmr\" . . .\n\n\n";
			break;
		}
	}

	s_inp >> std::boolalpha;  // to read 'true'/'false'

	std::string readed;
	s_inp >> readed;
	while (s_inp.good())
	{
		if (!aux_read::ReadBlock(s_inp, readed, s_mandatory_keys_read_func, s_optional_keys_read_func))
		{
			Log::SetWarning(Log::Warning::INVALID_KEYWORD, Log::GetLastValidKeyword(), aux_read::GetCurrentLine(s_inp), readed);
			return false;
		}
 	}

	IO::CheckAllMandatoryKeywords();
	return true;
}


bool IO::ReadKeypoints(std::string& readed)
{
	std::unordered_set<std::string_view> names;
	
	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "Keypoint")
		{
			// Create a new Keypoint object
			Keypoint* keypoint = &mm.keypoints.emplace_back();
			keypoint->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));
			
			names = { "X", "Y", "Z" };  // valid keywords
			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword
			
			// Read keywords
			while (s_inp >> readed && !names.empty())
			{
				// Extract node (handle) from set with names of the object parameters
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Keypoints", "Keypoint", names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "X")		keypoint->SetX(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Y")	keypoint->SetY(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Z")	keypoint->SetZ(aux_read::ReadVariable<double>(s_inp));
			}
		}
		else 
			break;
	} 

	// All OK while reading
	aux_read::RemoveDuplicates(mm.keypoints, "Keypoint");
	Log::SetLastValidKeyword("Keypoints");
	return true;
}

bool IO::ReadSegmentSets(std::string& readed)
{
	std::unordered_set<std::string_view> names;
	
	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "Set")
		{
			// Create a new SegmentSet object
			SegmentSet* set = &mm.segment_sets.emplace_back();
			set->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));

			// Read first keyword
			s_inp >> readed;
			while (s_inp.good())
			{
				LineSegment* seg;

				names = { "Length", "Property", "Discretization" };  // Valid keywords
				NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

				aux_read::TryCommentAndContinue(s_inp, readed);

				// Try to create a new LineSegment object at the end of 'segmentsets' container
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "SegmentSets", "Set", USET_SV{}, names);
				if (nh.empty() || readed == "Set")	break;
				else								seg = set->AddSegment();
				
				// Setting segment properties
				while (!names.empty() || !nh.empty())
				{
					std::string_view name = nh.value();
					if (name == "Length")				seg->SetLength(aux_read::ReadVariable<double>(s_inp));
					else if (name == "Property")		seg->SetProperty(aux_read::ReadVariable<unsigned int>(s_inp));
					else if (name == "Discretization")	seg->SetDiscretization(aux_read::ReadVariable<unsigned int>(s_inp));

					s_inp >> readed;

					// Extract node
					ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "SegmentSets", "SegmentSet", names);
					if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
					else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;
				} 
			}
		}
		else 
			break;
	} 

	// All OK while reading
	aux_read::RemoveDuplicates(mm.segment_sets, "SegmentSet");
	Log::SetLastValidKeyword("SegmentSets");
	return true;
}

bool IO::ReadLines(std::string& readed)
{
	std::unordered_set<std::string_view> names;

	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "Line")
		{
			// Create a new Keypoint object
			Line* line = &mm.lines.emplace_back();
			line->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));

			/* If is shared, one MUST define "Fairleads" or "VesselIDs" after the ID number
			   thus, it CAN NOT be "SegmentSet" in this case! */
			if (readed == "Fairleads" || readed == "VesselIDs")
			{
				names = { "Fairleads", "VesselIDs", "SegmentSet" };
				line->SetSharedOpt(true);
			}
			else
				names = { "Anchor", "Fairlead", "VesselID", "SegmentSet" };

			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			// Read keywords
			while (s_inp >> readed && !names.empty())
			{
				// Extract node (handle) from set with names of the object parameters
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Lines", "Line", names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "Anchor") { line->SetKeypointA(aux_read::Try2GetObjectID(s_inp, readed)); }
				else if (name == "Fairlead") { line->SetKeypointB(aux_read::Try2GetObjectID(s_inp, readed)); }
				else if (name == "VesselID") { line->SetVesselID(aux_read::Try2GetObjectID(s_inp, readed)); }
				else if (name == "SegmentSet") { line->SetSegmentSet(aux_read::Try2GetObjectID(s_inp, readed)); }
				// Shared line
				else if (name == "Fairleads")
				{
					// First fairlead
					line->SetKeypointA(aux_read::Try2GetObjectID(s_inp, readed));
					// Separator
					char ch = s_inp.get();
					if (ch != ',' && ch != ';')	return false;
					// Second fairlead
					line->SetKeypointB(aux_read::Try2GetObjectID(s_inp, readed));
				}
				else if (name == "VesselIDs")
				{
					// First vessel
					line->SetVesselID(aux_read::Try2GetObjectID(s_inp, readed));
					// Separator
					char ch = s_inp.get();
					if (ch != ',' && ch != ';')	return false;
					// Second vessel
					line->SetVesselID(aux_read::Try2GetObjectID(s_inp, readed));
				}
			}
		}
		else
			break;
	}

	// All OK while reading
	aux_read::RemoveDuplicates(mm.lines, "Line");
	Log::SetLastValidKeyword("Lines");
	return true;
}

bool IO::ReadVessels(std::string& readed)
{
	std::unordered_set<std::string_view> mandatory_names, optional_names;
	
	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "Vessel")
		{
			// Create a new Keypoint object
			Vessel* vessel = &mm.vessels.emplace_back();
			vessel->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));

			mandatory_names = { "PilotNode" };
			optional_names = { "InertiaTensor", "Mass" };

			NODE_HANDLE_USET_SV nh;
			
			// (try to) read first keyword before the do-while block 
			// because when we have optional keys we check th node handle, not the set with keywords
			s_inp >> readed;  
			do {
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Vessels", "Vessel", mandatory_names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "InertiaTensor")
				{
					vessel->SetInertiaTensor(aux_read::ReadFixedContainer<std::array<double, 6>, 6>(s_inp));
					continue;
				}

				if (name == "PilotNode")	vessel->SetKeypoint(aux_read::ReadVariable<unsigned int>(s_inp));
				else if (name == "Mass")	vessel->SetMass(aux_read::ReadVariable<float>(s_inp));
			} while (s_inp >> readed && !nh.empty());
		}
		else
			break;
	}

	// All OK while reading
	aux_read::RemoveDuplicates(mm.vessels, "Vessel");
	Log::SetLastValidKeyword("Vessels");
	return true;
}

bool IO::ReadSegmentProperties(std::string& readed)
{
	std::unordered_set<std::string_view> mandatory_names, optional_names;

	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "SegmentProperty")
		{
			// Create a new Keypoint object
			SegmentProperty* prop = &mm.segment_properties.emplace_back();
			prop->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));

			// Check segment type
			s_inp >> readed;
			if (readed == "truss")
			{
				prop->SetTrussOpt(true);
				mandatory_names = { "SpecificMass", "Diameter", "EA", "CDt", "CDn", "CAt", "CAn" };
				optional_names = { "SpecificGravity", "YoungModulus", "PoissonRatio", "InnerDiameter", "ContactDiameter", "MBS" };
			}
			else if (readed == "beam")
			{
				prop->SetBeamOpt(true);
				mandatory_names = { "SpecificMass", "Diameter", "EA", "CDt", "CDn", "CAt", "CAn", "EI", "GJ", "GA" };
				optional_names = { "SpecificGravity", "YoungModulus", "PoissonRatio", "InnerDiameter", "ContactDiameter", "MBS" };
			}
			else if (readed == "chain")
			{
				prop->SetChainOpt(true);
				mandatory_names = { "Diameter", "Type" };
				optional_names = { "MBS", "EA", "CDt", "CDn", "CAt", "CAn", "EI", "GJ", "GA", "InnerDiameter", "ContactDiameter" };
			}
			else
			{
				Log::SetWarning(Log::Warning::INVALID_KEYWORD, "SegmentProperties", aux_read::GetCurrentLine(s_inp), readed);
				return false;
			}

			NODE_HANDLE_USET_SV nh;

			// (try to) read first keyword before the do-while block 
			// because when we have optional keys we check th node handle, not the set with keywords
			s_inp >> readed;
			do {
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "SegmentProperties", "SegmentProperty", mandatory_names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "SpecificGravity")			prop->SetSG(aux_read::ReadVariable<double>(s_inp));
				else if (name == "SpecificMass")		prop->SetMass(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Diameter")			prop->SetDiameter(aux_read::ReadVariable<double>(s_inp));
				else if (name == "ContactDiameter")		prop->SetContactDiameter(aux_read::ReadVariable<double>(s_inp));
				else if (name == "InnerDiameter")		prop->SetInnerDiameter(aux_read::ReadVariable<double>(s_inp));
				else if (name == "EA")					prop->SetEA(aux_read::ReadVariable<double>(s_inp));
				else if (name == "EI")					prop->SetEI(aux_read::ReadVariable<double>(s_inp));
				else if (name == "GA")					prop->SetGA(aux_read::ReadVariable<double>(s_inp));
				else if (name == "GJ")					prop->SetGJ(aux_read::ReadVariable<double>(s_inp));
				else if (name == "CDt")					prop->SetCDt(aux_read::ReadVariable<double>(s_inp));
				else if (name == "CDn")					prop->SetCDn(aux_read::ReadVariable<double>(s_inp));
				else if (name == "CAt")					prop->SetCAt(aux_read::ReadVariable<double>(s_inp));
				else if (name == "CAn")					prop->SetCAn(aux_read::ReadVariable<double>(s_inp));
				else if (name == "MBS")					prop->SetMBS(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Type")				prop->SetWizardType(aux_read::ReadVariable<std::string>(s_inp));

			} while (s_inp >> readed && !nh.empty());
		}
		else
			break;
	}

	// All OK while reading
	aux_read::RemoveDuplicates(mm.segment_properties, "SegmentProperty");
	Log::SetLastValidKeyword("SegmentProperties");
	return true;
}

bool IO::ReadEnvironment(std::string& readed)
{
	std::unordered_set<std::string_view> names, optional_names;
	std::unordered_set<std::string_view> blocks = { "General", "Seabed", "SeaCurrent" };

	// Read first block
	s_inp >> readed;	
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);
		std::string_view key = aux_read::ExtractNodeValue(blocks, readed);

		if (key == "General")
		{
			// Create a new Keypoint object
			MoorEnvironment* env = &mm.environment;

			names = { "Gravity", "RhoFluid", "WaterDepth" };  // valid keywords
			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			// Read keywords
			while (s_inp >> readed && !names.empty())
			{
				// Extract node (handle) from set with names of the object parameters
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Environment", "General", names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "Gravity")			env->SetGravity(aux_read::ReadVariable<double>(s_inp));
				else if (name == "RhoFluid")	env->SetRhoFluid(aux_read::ReadVariable<double>(s_inp));
				else if (name == "WaterDepth")	env->SetWaterDepth(aux_read::ReadVariable<double>(s_inp));
			}
		}
		else if (key == "Seabed")
		{
			// Create a new Keypoint object
			Seabed* seabed = &mm.environment.GetSeabed();

			names = { "Stiffness", "Damping", "FrictionCoefficient" };  // valid keywords
			optional_names = { "StiffnessTangentialFactor" };
			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			// Read seabed type (for now, it MUST be "flat")
			s_inp >> readed;
			if (readed == "flat") 
				seabed->SetFlatOption(true);
			else
			{
				Log::SetWarning(Log::Warning::INVALID_KEYWORD, "Environment |> Seabed", aux_read::GetCurrentLine(s_inp), readed);
				return false;
			}

			// Read keywords
			s_inp >> readed;
			do {
				// Extract node (handle) from set with names of the object parameters
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Environment", "Seabed", names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "Stiffness")				seabed->SetStiffness(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Damping")				seabed->SetDamping(aux_read::ReadVariable<double>(s_inp));
				else if (name == "FrictionCoefficient")	seabed->SetFrictionCoefficient(aux_read::ReadVariable<double>(s_inp));
				else if (name == "StiffnessTangentialFactor")	seabed->SetStiffnessTangentialFactor(aux_read::ReadVariable<double>(s_inp));
			} while (s_inp >> readed && !nh.empty());
		}
		else if (key == "SeaCurrent")
		{
			s_inp >> readed;
			while (s_inp.good())
			{
				SeaCurrent* sc;

				names = { "Azimuth", "Speed", "Depth" };  // Valid keywords
				NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

				aux_read::TryCommentAndContinue(s_inp, readed);

				// Try to create a new SeaCurrent object at the end of 'sea_current' container
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Environment", "SeaCurrent", USET_SV{}, names);
				// If is not a valid keyword or valid block, break loop ...
				if (nh.empty() || blocks.count(readed) > 0)	break; 
				// Otherise, append a new object to the container
				else								sc = mm.environment.AddSeaCurrent();

				// Setting segment properties
				while (!names.empty() || !nh.empty())
				{
					std::string_view name = nh.value();
					if (name == "Depth")			sc->SetDepth(aux_read::ReadVariable<double>(s_inp));
					else if (name == "Speed")		sc->SetSpeed(aux_read::ReadVariable<double>(s_inp));
					else if (name == "Azimuth")		sc->SetAzimuth(aux_read::ReadVariable<double>(s_inp));

					s_inp >> readed;
					// Extract node
					ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Environment", "SeaCurrent", names);
					if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
					else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;
				}
			}
		}
		else
			break;
	}

	// All OK while reading
	Log::SetLastValidKeyword("Environment");
	return true;
}

bool IO::ReadSolution(std::string& readed)
{
	std::unordered_set<std::string_view> mandatory_names, optional_names;
	std::unordered_set<std::string_view> blocks = { "Analysis", "SeaCurrentStep", "DynamicRelaxation" };

	// Read first block
	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);
		std::string_view key = aux_read::ExtractNodeValue(blocks, readed);

		if (key == "DynamicRelaxation")
		{
			auto step = mm.moorsolution.InitDynRelaxLines();

			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			mandatory_names = { "Decrement" };
			optional_names = { "Duration", "Periods", "TimeStep", "MaxTimeStep", "MinTimeStep", "Sample" };
				
			// Setting solution properties
			s_inp >> readed;
			do {
				// Extract node
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Solution", "DynamicRelaxation", mandatory_names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "Decrement")				step->SetDecrement(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Periods")				step->SetPeriods(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Duration")				step->SetEndTime(aux_read::ReadVariable<double>(s_inp));
				else if (name == "TimeStep")			step->SetTimestep(aux_read::ReadVariable<double>(s_inp));
				else if (name == "MaxTimeStep")			step->SetMaxTimestep(aux_read::ReadVariable<double>(s_inp));
				else if (name == "MinTimeStep")			step->SetMinTimeStep(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Sample")				step->SetSample(aux_read::ReadVariable<int>(s_inp));
			} while (s_inp >> readed && !nh.empty());
			step->CheckAndSetMaxTimeStep();
			step->SetNewmarkDamping("extreme");
		}
		else if (key == "SeaCurrentStep")
		{
			auto step = mm.moorsolution.InitStepSeaCurrent();

			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			mandatory_names = { "Duration" };
			optional_names = { "TimeStep", "MaxTimeStep", "MinTimeStep", "Sample" };

			// Setting solution properties
			s_inp >> readed;
			do {
				// Extract node
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Solution", "SeaCurrentStep", mandatory_names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "Duration")						step->SetEndTime(aux_read::ReadVariable<double>(s_inp));
				else if (name == "TimeStep")			step->SetTimestep(aux_read::ReadVariable<double>(s_inp));
				else if (name == "MaxTimeStep")			step->SetMaxTimestep(aux_read::ReadVariable<double>(s_inp));
				else if (name == "MinTimeStep")			step->SetMinTimeStep(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Sample")				step->SetSample(aux_read::ReadVariable<int>(s_inp));
			} while (s_inp >> readed && !nh.empty());
			step->CheckAndSetMaxTimeStep();
		}
		else if (key == "Analysis")
		{
			s_inp >> readed;
			while (s_inp.good())
			{
				SolutionStep* step;
				
				NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword
				aux_read::TryCommentAndContinue(s_inp, readed);

				// Try to create a new SolutionStep object at the end of 'solution_steps' container
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Solution", "Analysis", USET_SV{}, USET_SV{ "Step" });
				// If is not a valid keyword or valid block, break loop ...
				if (nh.empty() || blocks.count(readed) > 0)	break;
				// ... otherise, append a new object to the container
				else										step = mm.moorsolution.AddSolutionStep();

				step->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));
				// Read solution type 
				s_inp >> readed;
				if (readed == "static")
				{
					step->SetStaticOpt(true);
					mandatory_names = { "Duration", "TimeStep", "MinTimeStep", "Sample"};
					optional_names = { "MaxTimeStep" };
				}
				else if (readed == "dynamic")
				{
					step->SetDynamicOpt(true);
					mandatory_names = { "Duration", "TimeStep", "MinTimeStep", "Sample", "NumericalDamping" };
					optional_names = { "MaxTimeStep", "RayleighDamping" };
				}
				else
				{
					Log::SetWarning(Log::Warning::INVALID_KEYWORD, "Solution", aux_read::GetCurrentLine(s_inp), readed);
					return false;
				}

				// Setting solution properties
				while (s_inp >> readed && !nh.empty())
				{
					// Extract node
					ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Solution", "Analysis", mandatory_names, optional_names);
					if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
					else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

					std::string_view name = nh.value();
					if (name == "Duration")					step->SetEndTime(aux_read::ReadVariable<double>(s_inp));
					else if (name == "TimeStep")			step->SetTimestep(aux_read::ReadVariable<double>(s_inp));
					else if (name == "MaxTimeStep")			step->SetMaxTimestep(aux_read::ReadVariable<double>(s_inp));
					else if (name == "MinTimeStep")			step->SetMinTimeStep(aux_read::ReadVariable<double>(s_inp));
					else if (name == "Sample")				step->SetSample(aux_read::ReadVariable<int>(s_inp));
					else if (name == "NumericalDamping")
					{
						// Try predefined parameter...
						if (!step->SetNewmarkDamping(aux_read::ReadVariable<std::string>(s_inp), readed))
						{
							// ... or define each coefficient explicitly
							std::unordered_set<std::string_view> coeffs = { "Beta", "Gamma" };
							for (int i : {1, 2})
							{
								auto nh = coeffs.extract(readed);
								if (nh.empty()) break;

								name = nh.value();
								if (name == "Beta")			step->SetBetaNewmark(aux_read::ReadVariable<double>(s_inp));
								else if (name == "Gamma")	step->SetGammaNewmark(aux_read::ReadVariable<double>(s_inp));
								
								// read second keyword
								if (i == 1) s_inp >> readed; 
							}

							if (coeffs.size())
							{
								Log::SetWarning(R"(
   + 'NumericalDamping' was defined, but Beta and/or Gamma was/were not defined. 
    You may want to defined both parameters or choose one of the following keywords for setting predefined parameters:

	 ------------------------------
	|  Keyword   |  Beta |  Gamma  |
	|------------|-------|---------|
	|  null      |  0.3  |  0.500  |
	|  mild      |  0.3  |  0.505  |
	|  moderate  |  0.3  |  0.520  |
	|  high      |  0.3  |  0.550  |
	|  extreme   |  0.3  |  0.600  |
	 ------------------------------)");
							}
						}
					}
					else if (name == "RayleighDamping")
					{
						// Read two coefficients
						for (int cont : {1, 2})
						{
							s_inp >> readed;
							if (readed == "Alpha")		step->SetAlphaRayleigh(aux_read::ReadVariable<double>(s_inp));
							else if (readed == "Beta")	step->SetBetaRayleigh(aux_read::ReadVariable<double>(s_inp));
							else
							{
								Log::SetWarning("   + 'RayleighDamping' was defined, but Alpha and/or Beta was/were not defined.");
								aux_read::BackLastWord(s_inp, readed);
								break;
							}
						}
					}
				} /*-- properties setting --*/
				step->CheckAndSetMaxTimeStep();
			}
		} /*-- end analysis --*/
		else
			break;
	}

	// If no analysis step is defined the user must be warned
	if (mm.moorsolution.GetStepsVec().size() == 0) 
		Log::SetWarning(R"(
  No analysis step was defined, thus GiraffeMoor only create the 'setting' models. 
  You can check the *.sum file and the user's manual for details.)"
		);

	// All OK while reading
	Log::SetLastValidKeyword("Solution");
	return true;
}

bool IO::ReadGiraffeSolver(std::string& readed)
{
	std::unordered_set<std::string_view> mandatory_names, optional_names;
	std::unordered_set<std::string_view> blocks = { "Run", "Processors", "ConvergenceCriteria" };

	// Read first block
	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);
		std::string_view key = aux_read::ExtractNodeValue(blocks, readed);

		if (key == "Run")
		{
			// Read boolean
			gm.gir_solver.SetRunGiraffeOpt(aux_read::ReadVariable<bool>(s_inp));

			// Read next keyword
			s_inp >> readed;
		}
		else if (key == "Processors")
		{
			GiraffeSolver* solver = &gm.gir_solver;

			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			mandatory_names = { };
			optional_names = { "Cores", "LinSys" };

			// Setting solution properties
			s_inp >> readed;
			do {
				// Extract node
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "GiraffeSolver", "Processors", mandatory_names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "Cores")		solver->SetCores(aux_read::ReadVariable<unsigned int>(s_inp));
				else if (name == "LinSys")	solver->SetLinSolverOpt(aux_read::ReadVariable<std::string>(s_inp));

			} while (s_inp >> readed && !nh.empty());
		}
		else if (key == "ConvergenceCriteria")
		{
			ConvergenceCriteria* conv_criteria = &gm.gir_solver.GetConvCriteria();

			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			mandatory_names = { };
			optional_names = { "ForceTolerance", "MomentTolerance", "ForceMinimumReference", "MomentMinimumReference",
				"ConstraintMinimumReference", "DisplacementTolerance", "RotationTolerance", "LagrangeTolerance",
				"DisplacementMinimumReference", "RotationMinimumReference", "LagrangeMinimumReference", "DivergenceReference" };

			// Setting Convergence criteria 
			s_inp >> readed;
			do {
				aux_read::TryCommentAndContinue(s_inp, readed);

				// Extract node
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "GiraffeSolver", "ConvergenceCriteria", mandatory_names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "ForceTolerance")						conv_criteria->force_tol = aux_read::ReadVariable<double>(s_inp);
				else if (name == "MomentTolerance")					conv_criteria->moment_tol = aux_read::ReadVariable<double>(s_inp);
				else if (name == "ForceMinimumReference")			conv_criteria->force_min = aux_read::ReadVariable<double>(s_inp);
				else if (name == "MomentMinimumReference")			conv_criteria->moment_min = aux_read::ReadVariable<double>(s_inp);
				else if (name == "ConstraintMinimumReference")		conv_criteria->constraint_min = aux_read::ReadVariable<double>(s_inp);
				else if (name == "DisplacementTolerance")			conv_criteria->disp_tol = aux_read::ReadVariable<double>(s_inp);
				else if (name == "RotationTolerance")				conv_criteria->rot_tol = aux_read::ReadVariable<double>(s_inp);
				else if (name == "LagrangeTolerance")				conv_criteria->lag_tol = aux_read::ReadVariable<double>(s_inp);
				else if (name == "DisplacementMinimumReference")	conv_criteria->disp_min = aux_read::ReadVariable<double>(s_inp);
				else if (name == "RotationMinimumReference")		conv_criteria->rot_min = aux_read::ReadVariable<double>(s_inp);
				else if (name == "LagrangeMinimumReference")		conv_criteria->lag_min = aux_read::ReadVariable<double>(s_inp);
				else if (name == "DivergenceReference")				conv_criteria->divergence_ref = aux_read::ReadVariable<double>(s_inp);
			
			} while (s_inp >> readed && !nh.empty());
			
		} 
		else
			break;
	}


	// All OK while reading
	Log::SetLastValidKeyword("GiraffeSolver");
	return true;
}

bool IO::ReadPostProcessing(std::string& readed)
{
	std::unordered_set<std::string_view> mandatory_names, optional_names;
	std::unordered_set<std::string_view> blocks = { "PostFiles", "CADs"};

	// Read first block
	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);
		std::string_view key = aux_read::ExtractNodeValue(blocks, readed);

		if (key == "PostFiles")
		{
			WritingFlags* flags = &mm.moorpost.GetWritingFlags();

			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			mandatory_names = { };
			optional_names = { "none", "Mesh", "RenderMesh", "RigidContactSurfaces", 
				"FlexibleContactSurfaces", "Constraints", "Forces", "SpecialConstraints", 
				"ContactForces", "RenderParticles", "RenderRigidBodies" };

			// Setting post files options
			s_inp >> readed;
			do {
				aux_read::TryCommentAndContinue(s_inp, readed);

				// Extract node
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "PostProcessing", "PostFiles", mandatory_names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (readed == "none")
				{ 
					flags->SetAllFlags(false);
					break;
				}
				else if (readed == "RenderRigidBodies")			flags->SetRenderRigidBodiesFlag(true);
				else if (readed == "Forces")					flags->SetForcesFlag(true);
				else if (readed == "ContactForces")				flags->SetContactForcesFlag(true);
				else if (readed == "RigidContactSurfaces")		flags->SetRigidContactSurfacesFlag(true);
				else if (readed == "RenderMesh")				flags->SetRenderMeshFlag(true);
				else if (readed == "Constraints")				flags->SetConstraintsFlag(true);
				else if (readed == "SpecialConstraints")		flags->SetSpecialConstraintsFlag(true);
				else if (readed == "Mesh")						flags->SetMeshFlag(true);
				else if (readed == "FlexibleContactSurfaces")	flags->SetFlexibleContactSurfacesFlag(true);
				else if (readed == "RenderParticles")			flags->SetRenderParticlesFlag(true);
				else if (readed == "All")						flags->SetAllFlags(true);

			} while (s_inp >> readed && !nh.empty());
		}
		else if (key == "CADs")
		{
			s_inp >> readed;
			while (!s_inp.eof())
			{
				CADData* cad;

				NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword
				mandatory_names = { "VesselID", "FileName" };

				// Try to create a new CADData object at the end of 'vessel_cads' container
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Solution", "Analysis", mandatory_names);
				// If is not a valid keyword or valid block, break loop ...
				if (nh.empty() || blocks.count(readed) > 0)	break;
				// ... otherise, append a new object to the container
				else										cad = mm.moorpost.AddVesselCAD();

				// Setting CAD properties
				do {
					std::string_view name = nh.value();
					if (name == "VesselID")			cad->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));
					else if (name == "FileName")	cad->SetName(aux_read::ReadDelimitedString(s_inp, std::array{ '\"', '\"' }));
					
					// Extract node
					s_inp >> readed;
					auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Solution", "Analysis", mandatory_names);
					if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
					else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				} while (!nh.empty());
			}
		}
		else
			break;
	}


	// All OK while reading
	Log::SetLastValidKeyword("PostProcessing");
	return true;
}

bool IO::ReadStiffnessMatrix(std::string& readed)
{
	mm.stiff_matrix = std::make_unique<StiffnessMatrix>();

	std::unordered_set<std::string_view> names;
	std::unordered_set<std::string_view> blocks = { "Analytical" };

	// Read blocks
	while (s_inp >> readed)
	{
		aux_read::TryCommentAndContinue(s_inp, readed);
		std::string_view key = aux_read::ExtractNodeValue(blocks, readed);

		if (key == "Analytical")
			mm.stiff_matrix->SetAnalyticalStiffnessOpt(aux_read::ReadVariable<bool>(s_inp));
		else
			break;
	}

	// All OK while reading
	Log::SetLastValidKeyword("StiffnessMatrix");
	return true;
}

bool IO::ReadVesselDisplacements(std::string& readed)
{
	//TODO: retirar 'insert's e melhorar leitura de cada tipo de deslocamento

	std::unordered_set<std::string_view> names;

	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "DispVesselID")
		{
			// Create a new Keypoint object
			VesselDisplacement* disp = &mm.vessel_displacements.emplace_back();
			disp->SetVesselID(aux_read::Try2GetObjectID(s_inp, readed));

			names = { "Step", "TimeSeries", "MathCode", "File" };  // valid keywords
			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			// Setting properties
			while (s_inp >> readed && !names.empty())
			{
				// Extract node (handle) from set with names of the object parameters
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "VesselDisplacements", "VesselDisplacement", names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK || nh.empty())	break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)			return false;

				std::string_view name = nh.value();
				if (name == "Step")		disp->SetSolutionStep(aux_read::ReadVariable<unsigned int>(s_inp));
				else if (name == "TimeSeries")
				{
					names.erase("MathCode");
					names.erase("File");
					names.insert("TimeSeriesData");
					disp->SetTimeSeries();
				}
				else if (name == "TimeSeriesData")
					*disp->GetTimeSeries() = aux_read::ReadTable(s_inp);
				/*-- External file --*/
				else if (name == "File")
				{
					// Remove other options...
					names.erase("TimeSeries");
					names.erase("MathCode");
					//... and insert keywords to read external file
					names.insert({ "FileName", "NTimes", "NHeaders" });
				}
				else if (name == "FileName")	disp->SetFileName(aux_read::ReadDelimitedString(s_inp, std::array{ '\"', '\"' }));
				else if (name == "NTimes")		disp->SetFileNSteps(aux_read::ReadVariable<unsigned int>(s_inp));
				else if (name == "NHeaders")	disp->SetFileHeaders(aux_read::ReadVariable<unsigned int>(s_inp));
				/*-- MathCode --*/
				else if (name == "MathCode")
				{
					// Remove other options...
					names.erase("TimeSeries");
					names.erase("File");
					//... and insert keywords to read MathCode (DOFs)
					names.insert({ "X", "Y", "Z", "ROTX", "ROTY", "ROTZ" });

					disp->SetMathCode();
				}
				else if (name == "X")		disp->GetMathCode()->SetEquation(0, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "Y")		disp->GetMathCode()->SetEquation(1, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "Z")		disp->GetMathCode()->SetEquation(2, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "ROTX")	disp->GetMathCode()->SetEquation(3, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "ROTY")	disp->GetMathCode()->SetEquation(4, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "ROTZ")	disp->GetMathCode()->SetEquation(5, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
			}
		}
		else
			break;
	}

	// All OK while reading
	aux_read::RemoveDuplicates(mm.vessel_displacements, "VesselDisplacement");
	Log::SetLastValidKeyword("VesselDisplacements");
	return true;
}

bool IO::ReadConstraints(std::string& readed)
{
	std::unordered_set<std::string_view> blocks = { "VesselConstraints", "AnchorConstraints", "LineConstraints" };

	MoorConstraint* constraint{};  // Constraint object 
	std::string_view keyword;  // ID identifier
	
	// Lambda function to create object and return a reference 
	std::function<MoorConstraint* (void)> emplace_constraint;

	// Read first block
	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "VesselConstraints")
		{
			keyword = "VesselID";
			emplace_constraint = []() { return &mm.vessel_constraints.emplace_back(); };
		}
		else if (readed == "AnchorConstraints")
		{
			keyword = "LineID";
			emplace_constraint = []() { return &mm.anchor_constraints.emplace_back(); };
		}
		else if (readed == "LineConstraints")
		{
			keyword = "LineID";
			emplace_constraint = []() { return &mm.line_constraints.emplace_back(); };
		}
		else
			break;

		s_inp >> readed;
		while (s_inp.good())
		{
			// Searches for keyword
			aux_read::TryCommentAndContinue(s_inp, readed);
			
			// Check if is from the same block
			if (readed != keyword)	break;
			
			// Append a new MoorConstraint
			constraint = emplace_constraint();
			constraint->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));

			// Read constraint data
			std::unordered_set<std::string_view> DoFs{ "X", "Y", "Z", "ROTX", "ROTY", "ROTZ" };

			unsigned int dof = 0;

			// Read booltables
			s_inp >> readed;
			do {
				// Check DoF
				if (DoFs.count(readed) == 0)	break;
				else							DoFs.erase(readed);

				if (readed == "X")			dof = 0;
				else if (readed == "Y")		dof = 1;
				else if (readed == "Z")		dof = 2;
				else if (readed == "ROTX")	dof = 3;
				else if (readed == "ROTY")	dof = 4;
				else if (readed == "ROTZ")	dof = 5;

				// read options (MUST be '1' or '0')
				while (s_inp >> readed && std::isdigit(readed[0]))
					constraint->PushToDof(dof, readed[0] == '1');
			} while (s_inp.good());
		}
	}

	// All OK while reading
	Log::SetLastValidKeyword("Constraints");
	return true;
}

bool IO::ReadNodalLoads(std::string& readed)
{
	//TODO: retirar 'insert's e melhorar leitura de cada tipo de deslocamento

	std::unordered_set<std::string_view> mandatory_names;
	std::unordered_set<std::string_view> optional_names;
	std::unordered_set<std::string_view> descriptions = { "first", "last", "vessel" };

	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "Node")
		{
			// Create a new Keypoint object
			MoorLoad* load = &mm.moor_loads.emplace_back();

			// valid keywords
			mandatory_names = { "Step", "MathCode", "File", "TimeSeries", "TimeSeriesData" };
			optional_names = { "SegmentID", "LineID" };
			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword
			
			// Node description and/or ID number
			s_inp >> readed;
			if (descriptions.count(readed))
			{
				load->SetDescription(readed);
				if (readed == "vessel")	
					load->SetNodeID(aux_read::ReadVariable<unsigned int>(s_inp));
			}
			else if (std::isdigit(readed[0]))
				load->SetNodeID(std::stoul(readed));

			// (try to) read first keyword before the do-while block 
			// because when we have optional keys we check th node handle, not the set with keywords
			s_inp >> readed;
			do {
				// Extract node (handle) from set with names of the object parameters
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "NodalLoads", "NodalLoad", mandatory_names, optional_names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK || nh.empty())	break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)			return false;

				std::string_view name = nh.value();
				if (name == "Step")		load->SetSolutionStep(aux_read::ReadVariable<unsigned int>(s_inp));
				else if (name == "TimeSeries")
				{
					mandatory_names.erase("MathCode");
					mandatory_names.erase("File");
					mandatory_names.insert("TimeSeriesData");
					load->SetTimeSeries();
				}
				else if (name == "TimeSeriesData")
				{
					*load->GetTimeSeries() = aux_read::ReadTable(s_inp);
				}
				/*-- External file --*/
				else if (name == "File")
				{
					// Remove other options...
					mandatory_names.erase("TimeSeries");
					mandatory_names.erase("TimeSeriesData");
					mandatory_names.erase("MathCode");
					//... and insert keywords to read external file
					mandatory_names.insert({ "FileName", "NTimes", "NHeaders" });
				}
				else if (name == "FileName")	load->SetFileName(aux_read::ReadDelimitedString(s_inp, std::array{ '\"', '\"' }));
				else if (name == "NTimes")		load->SetFileNSteps(aux_read::ReadVariable<unsigned int>(s_inp));
				else if (name == "NHeaders")	load->SetFileHeaders(aux_read::ReadVariable<unsigned int>(s_inp));
				/*-- MathCode --*/
				else if (name == "MathCode")
				{
					// Remove other options...
					mandatory_names.erase("TimeSeries");
					mandatory_names.erase("TimeSeriesData");
					mandatory_names.erase("File");
					//... and insert keywords to read MathCode (DOFs)
					mandatory_names.insert({ "X", "Y", "Z", "ROTX", "ROTY", "ROTZ" });

					load->SetMathCode();
				}
				else if (name == "X")			load->GetMathCode()->SetEquation(0, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "Y")			load->GetMathCode()->SetEquation(1, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "Z")			load->GetMathCode()->SetEquation(2, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "ROTX")		load->GetMathCode()->SetEquation(3, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "ROTY")		load->GetMathCode()->SetEquation(4, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "ROTZ")		load->GetMathCode()->SetEquation(5, aux_read::ReadDelimitedString(s_inp, std::array{ '{', '}' }));
				else if (name == "SegmentID")	load->SetSegment(aux_read::ReadVariable<unsigned int>(s_inp));
				else if (name == "LineID")		load->SetLineID(aux_read::ReadVariable<unsigned int>(s_inp));
				
			} while (s_inp >> readed && !nh.empty());
		}
		else
			break;
	}

	// All OK while reading
	//aux_read::RemoveDuplicates(mm.moor_loads, "NodalLoad");
	Log::SetLastValidKeyword("NodalLoads");
	return true;
}

bool IO::ReadMonitors(std::string& readed)
{
	Monitor* monitors = &gm.monitor;

	std::unordered_set<std::string_view> blocks = { "General", "Elements", "Nodes", "Contacts" };
	std::unordered_set<std::string_view> names = {
		"none", "all", "fairleads", "anchors", "vessels",
		"Sequence", "List"
	};

	// Read first block
	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);
		std::string_view key = aux_read::ExtractNodeValue(blocks, readed);

		if (key == "Nodes")
		{
			// Setting nodes monitors
			s_inp >> readed;
			do {
				aux_read::TryCommentAndContinue(s_inp, readed);

				// Check if is other block or is not a valid 'name'
				if (blocks.count(readed) || names.count(readed) == 0) 
					break;

				std::string_view name = readed;
				if (name == "none")
				{
					monitors->SetAllNodesFlags(false);
					break;
				}
				else if (name == "all")
				{
					monitors->SetAllNodesFlags(false);
					break;
				}
				else if (name == "fairleads")	monitors->SetMonitorFairleadNodesOpt(true);
				else if (name == "anchors")		monitors->SetMonitorAnchorNodesOpt(true);
				else if (name == "vessels")		monitors->SetMonitorVesselNodesOpt(true);
				else if (name == "Sequence")
				{
					NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword
					auto* seq_ptr = monitors->AddNodesSequence();

					std::unordered_set<std::string_view> keywords = { "NNodes", "Begin", "Increment" };
					// Setting nodes monitors
					s_inp >> readed;
					do {
						// Extract node
						auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Monitors", "Nodes", keywords);
						if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
						else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

						std::string_view name = nh.value();
						if (name == "NNodes")			seq_ptr->nodes = aux_read::ReadVariable<unsigned int>(s_inp);
						else if (name == "Begin")		seq_ptr->begin = aux_read::ReadVariable<unsigned int>(s_inp);
						else if (name == "Increment")	seq_ptr->increment = aux_read::ReadVariable<unsigned int>(s_inp);

					} while (s_inp >> readed && !nh.empty());					
					continue;  // next word may be another valid Keyword, eg List, anchors, etc
				}
				else if (name == "List")
				{
					while (s_inp >> readed && std::isdigit(readed[0]))
						monitors->PushNodeID(std::stoul(readed));
					continue;  // next word may be another valid Keyword, eg Sequence, fairleads, etc
				}

				s_inp >> readed;
			} while (s_inp.good());
		}
		else if (key == "Elements")
		{
			// Setting element monitors
			s_inp >> readed;
			do {
				aux_read::TryCommentAndContinue(s_inp, readed);

				// Check if is other block or is not a valid 'name'
				if (blocks.count(readed) || names.count(readed) == 0)
					break;

				std::string_view name = readed;
				if (name == "none")
				{
					monitors->SetAllElementsFlags(false);
					break;
				}
				else if (name == "all")
				{
					monitors->SetAllElementsFlags(false);
					break;
				}
				else if (name == "fairleads")	monitors->SetMonitorFairleadElementsOpt(true);
				else if (name == "anchors")		monitors->SetMonitorAnchorElementsOpt(true);
				else if (name == "vessels")		monitors->SetMonitorVesselElementsOpt(true);
				else if (name == "Sequence")
				{
					NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

					auto* seq_ptr = monitors->AddElementsSequence();

					std::unordered_set<std::string_view> keywords = { "NNodes", "Begin", "Increment" };
					// Setting nodes monitors
					s_inp >> readed;
					do {
						// Extract node
						auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Monitors", "Nodes", keywords);
						if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
						else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

						std::string_view name = nh.value();
						if (name == "NNodes")		seq_ptr->elements = aux_read::ReadVariable<unsigned int>(s_inp);
						if (name == "Begin")		seq_ptr->begin = aux_read::ReadVariable<unsigned int>(s_inp);
						if (name == "Increment")	seq_ptr->increment = aux_read::ReadVariable<unsigned int>(s_inp);

					} while (s_inp >> readed && !nh.empty());
				}
				else if (name == "List")
				{
					while (s_inp >> readed && std::isdigit(readed[0]))
						monitors->PushElementID(std::stoul(readed));
					
					continue;
				}

				s_inp >> readed;
			} while (s_inp.good());
		}
		else if (key == "Contacts")
		{
			// Setting contact monitors
			if (s_inp >> readed && readed == "lines|seabed")	monitors->SetMonitorLinesSeabedContactOpt(true);
			else												break;
			
			s_inp >> readed;
		}
		else if (key == "General")
		{
			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			// Setting nodes monitors
			s_inp >> readed;
			do {
				// Extract node
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "Monitors", "Nodes", USET_SV{}, USET_SV{ "Sample" });
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK)			break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)	return false;

				std::string_view name = nh.value();
				if (name == "Sample")	monitors->SetSample(aux_read::ReadVariable<unsigned int>(s_inp));

			} while (s_inp >> readed && !nh.empty());
		}
		else
			break;
	}


	// All OK while reading
	Log::SetLastValidKeyword("Monitors");
	return true;
}

bool IO::ReadLineDisplacementFields(std::string& readed)
{
	//TODO: retirar 'insert's e melhorar leitura de cada tipo de deslocamento

	std::unordered_set<std::string_view> names;

	s_inp >> readed;
	while (s_inp.good())
	{
		aux_read::TryCommentAndContinue(s_inp, readed);

		if (readed == "DispLineID")
		{
			// Create a new Keypoint object
			LineDisplacementField* disp = &mm.line_disp_fields.emplace_back();
			disp->SetIDNumber(aux_read::Try2GetObjectID(s_inp, readed));

			names = { "Step", "Harmonic" };  // valid keywords
			NODE_HANDLE_USET_SV nh;  // node handle -> check if is a valid keyword

			// Setting properties
			while (s_inp >> readed && !names.empty())
			{
				// Extract node (handle) from set with names of the object parameters
				auto ret = aux_read::ExtractNodeHandle(s_inp, nh, readed, "DisplacementFields", "LineID", names);
				if (ret == aux_read::NODE_EXTRACTION_STATUS::BREAK || nh.empty())	break;
				else if (ret == aux_read::NODE_EXTRACTION_STATUS::FALSE)			return false;

				std::string_view name = nh.value();
				if (name == "Harmonic")
				{
					names.insert("Amplitude");
					names.insert("Mode");
				}
				else if (name == "Step")		disp->SetSolutionStep(aux_read::ReadVariable<unsigned int>(s_inp));
				else if (name == "Amplitude")	disp->SetAmplitude(aux_read::ReadVariable<double>(s_inp));
				else if (name == "Mode")		disp->SetMode(aux_read::ReadVariable<unsigned int>(s_inp));
			}
		}
		else
			break;
	}

	// All OK while reading
	aux_read::RemoveDuplicates(mm.line_disp_fields, "LineDisplacementFields");
	Log::SetLastValidKeyword("LineDisplacementFields");
	return true;
}



bool IO::CheckAllMandatoryKeywords()
{
	//Checks if all mandatory blocks were defined
	if (!s_mandatory_keys_read_func.empty())
	{
		//Initial message
		std::string w = std::string("\n   + ") + std::to_string(s_mandatory_keys_read_func.size()) + " mandatory block(s) missed:\n";
		Log::SetWarning(w);

			//Appends missed mandatory keywords
		for (auto const& element : s_mandatory_keys_read_func)
		{
			Log::SetWarning(element.first);
			Log::SetWarning("\n");
		}
		return false;
	}


	//All ok while reading
	return true;
}


//Check input data before trying to generate the FE model
bool IO::CheckModel()
{
	/// <summary>
	/// 
	/// Talvez seja interessante criar funções para checar cada caso e colocar tudo em um único loop.
	/// Ficaria mais inteligível e fácil de ampliar - principalmente se essas funções auxiliares forem templates
	/// 
	/// </summary>
	/// 
	/// <returns> booleano q indica se o modelo passou por todas as etapas </returns>


	//Check if segments must be generated from 'SegmentSet'
	mm.GenerateSegments();

	std::map<std::string_view, size_t> n_keywords{
		//Mandatory blocks
		{"Keypoints", (unsigned int)mm.keypoints.size()}, 
		{"Lines", (unsigned int)mm.lines.size()}, 
		{"Vessels", (unsigned int)mm.vessels.size()},
		{"SegmentProperties", (unsigned int)mm.segment_properties.size()}, 
		{"SolSteps", (unsigned int)mm.moorsolution.GetStepsVec().size()},
		/*nothing to check:*/
		{"Environment", 1}, {"Solution", 1},
	};

	//Stream with warning message(s)
	std::stringstream ss;
	
	///
	/// Checks mandatory keywords
	///
	
	/*--- Keypoints ---*/
	if (mm.keypoints.front().GetIDNumber() != 1 || mm.keypoints.back().GetIDNumber() != n_keywords["Keypoints"])
		ss << "\n   + Invalid keypoint numbering";
	/*--- Segment properties ---*/
	if (mm.segment_properties.front().GetNumber() != 1 || mm.segment_properties.back().GetNumber() == n_keywords["SegProp"])
		ss << "\n   + Invalid segment property numbering";
	/*--- Lines ---*/
	if (mm.lines.front().GetNumber() != 1 || mm.lines.back().GetNumber() != n_keywords["Lines"])
		ss << "\n   + Invalid line numbering";
	{
		std::for_each(mm.lines.cbegin(), mm.lines.cend(), [&](const Line& line) {
			if (line.GetKeypointA() > n_keywords["Keypoints"] || line.GetKeypointB() > n_keywords["Keypoints"])
				ss << "\n   + Invalid keypoint referenced at line number " << line.GetNumber();
			if (!line.GetSegmentSetOpt())
				std::for_each(line.GetAllSegments().cbegin(), line.GetAllSegments().cend(), [&](const LineSegment& seg) {
				if (seg.GetProperty() > n_keywords["SegmentProperties"])
					ss << "\n   + Invalid segment property referenced at line number " << line.GetNumber(); }
			);//end of nested for_each (segments)
		});//end of first for_each (lines)
	}
	/*--- Vessels ---*/
	if (mm.vessels.front().GetNumber() != 1 || mm.vessels.back().GetNumber() != n_keywords["Vessels"])
		ss << "\n   + Invalid vessel numbering";
	{
		std::for_each(mm.vessels.cbegin(), mm.vessels.cend(), [&](const Vessel& vessel) {
			if (vessel.GetKeypoint() > n_keywords["Keypoints"])
				ss << "\n   + Invalid pilot node referenced at vessel number " << vessel.GetNumber(); }
		);//end of for_each
	}
	/*--- Solution steps ---*/
	if (mm.moorsolution.GetStepsVec().front().GetNumber() != 1 || mm.moorsolution.GetStepsVec().back().GetNumber() != n_keywords["SolSteps"])
		ss << "\n   + Invalid solution steps numbering";
	
	/// 
	/// Checks optional keywords
	/// 
	
	/*--- Segment sets ---*/
	if (!mm.segment_sets.empty())
	{
		std::for_each(mm.segment_sets.cbegin(), mm.segment_sets.cend(), [&](const SegmentSet& set) {
			std::for_each(set.GetAllSegment().cbegin(), set.GetAllSegment().cend(), [&](const LineSegment& seg) {
				if (seg.GetProperty() > n_keywords["Keypoints"])
					ss << "\n   + Invalid segment property referenced at segment set number " << set.GetIDNumber();
			});//end of nested for_each (line segments)
		});//end of first for_each (segment set)
	}
	/*--- Vessel displacements ---*/
	if (!mm.vessel_displacements.empty())
	{
		std::for_each(mm.vessel_displacements.cbegin(), mm.vessel_displacements.cend(), [&](const VesselDisplacement& disp) {
			if (disp.GetVesselID() > n_keywords["Vessels"]) 
				ss << "\n   + Invalid vessel ID to apply displacement: " << disp.GetVesselID() ;
			if (disp.GetStep() > n_keywords["SolSteps"] )
				ss << "\n   + Invalid analysis step number to displace the vessel number " << disp.GetVesselID() << ": " << disp.GetStep();
		});//end for (vessel displacements)
	}
	/*--- Platforms ---*/
	if (!mm.moorpost.GetAllVesselCADs().empty())
	{
		std::for_each(mm.moorpost.GetAllVesselCADs().cbegin(), mm.moorpost.GetAllVesselCADs().cend(), [&](const CADData& c) {
			if (c.GetNumber() > n_keywords["Vessels"]) 
				ss << "\n   + \"" << c.GetNumber() << "\" is not a valid vessel ID to link a CAD file";
		});
	}
	/*--- Displacement fields ---*/
	if (!mm.line_disp_fields.empty())
	{
		std::for_each(mm.line_disp_fields.cbegin(), mm.line_disp_fields.cend(), [&](const LineDisplacementField& disp) {
			if (disp.GetNumber() > n_keywords["Lines"]) 
				ss << "\n   + Invalid line ID to apply displacement field: " << disp.GetNumber();
			if (disp.GetStep() > n_keywords["SolSteps"])
				ss << "\n   + Invalid analysis step number to displace the vessel number " << disp.GetNumber() << ": " << disp.GetStep();
		});//end for (displacement fields)
	}
	/*--- Loads ---*/
	if (!mm.moor_loads.empty())
	{
		std::for_each(mm.moor_loads.cbegin(), mm.moor_loads.cend(), [&](const MoorLoad& load) {
			//Description
			auto description = load.GetDescription();
			
			//Check vessel number
			if (description == "vessel")
			{
				if ( load.GetNodeID() > n_keywords["Vessels"] )
					ss << "\n   + Invalid vessel number to apply load: " << load.GetNodeID(); 
			}
			else 
			{ 
				//Check line number
				if (load.GetLineID() > n_keywords["Lines"])
					ss << "\n   + Invalid line number to apply load: " << load.GetLineID();
				if (unsigned int seg = load.GetSegmentID() && load.GetLineID())
				{
					//With segment defined (not using SegmentSet)
					if (mm.lines[load.GetLineID() - 1].GetNSegments() > 0 && seg > n_keywords["SegmentProperties"])
						ss << "\n   + Invalid segment number to apply load: " << load.GetNodeID() << " at line number " << load.GetLineID();
					//Seg == 0 -> use SegmentSet 
					else
					{
						// No segment set: 
						if (mm.segment_sets.empty())
							ss << "\n   + Invalid segment number to apply load at line number " << load.GetLineID() << ":  no SegmentSet defined";
						else
						{ // Check segment set
							unsigned int segset_size = mm.segment_sets[mm.lines[load.GetLineID() - 1].GetSegmentSet() - 1].GetSegmentSetSize();
							if (seg > segset_size)
							{
								ss << "\n   + Invalid segment number to apply load at line number " << load.GetLineID() << ": segment number " <<
									seg << " is not defined at SegmentSet number " << mm.lines[load.GetLineID() - 1].GetSegmentSet();
							}
						}
					}// end 'seg == 0'
				}
			} // end 'else vessel'

		});//end for (loads)
	}
	/*--- Constraints ---*/
	{
		//MoorConstraint* constrPtr = &mm.moor_constraint; //pointer to MoorConstraint
		//if (constrPtr->ExistAnchorConstraint())
		//{
		//	std::for_each(constrPtr->GetAnchorConstraints().cbegin(), constrPtr->GetAnchorConstraints().cend(), [&](const AnchorConstraint& c) {
		//		if (c.GetNumberID() > n_keywords["Lines"])
		//			ss << "\n   + \"" << c.GetNumberID() << "\" is not a valid line ID to change its anchor constraint";
		//		});
		//}
		//if (constrPtr->ExistVesselConstraint())
		//{
		//	std::for_each(constrPtr->GetVesselConstraints().cbegin(), constrPtr->GetVesselConstraints().cend(), [&](const VesselConstraint& c) {
		//		if (c.GetNumberID() > n_keywords["Vessels"])
		//			ss << "\n   + \"" << c.GetNumberID() << "\" is not a valid vessel ID to change its constraints";
		//		});
		//}
		//if (constrPtr->ExistLineConstraint())
		//{
		//	std::for_each(constrPtr->GetLineConstraints().cbegin(), constrPtr->GetLineConstraints().cend(), [&](const LineConstraint& c) {
		//		if (c.GetNumberID() > n_keywords["Lines"])
		//			ss << "\n   + \"" << c.GetNumberID() << "\" is not a valid line ID to change its constraints";
		//		});
		//}
	}

	// Checking status
	bool modelOk = true;
	
	/// Approach for check empty stringstream adapted from 
	/// https://stackoverflow.com/questions/8046357/how-do-i-check-if-a-stringstream-variable-is-empty-null/36327567
	if (ss.peek() != decltype(ss)::traits_type::eof())
	{
		Log::SetWarning(ss.str());
		modelOk = false;
	}


	return modelOk;
}

//Writes Giraffe model file
void IO::WriteGiraffeModelFile()
{
	//Giraffe input file
	std::string full_name(folder_name + input_name + ".inp");
	std::ofstream fgir(full_name, std::ofstream::out);

	fgir << "/////////////////////////////////////////////////////////////////////////////\n";
	fgir << "//                                                                         //\n";
	fgir << "//   GIRAFFE input file generated automatically by GIRAFFEMoor v" << version << "  //\n";
	fgir << "//                                                                         //\n";
	fgir << "/////////////////////////////////////////////////////////////////////////////\n\n";

	fgir << "\n/*Units:\n\tTime: s\n\tMass: kg\n\tLinear: m\n\tForce: N\n\tRotation: rad\n\tAzimuth: degree\n*/\n";

	//General formatting
	fgir.setf(std::ofstream::scientific);	//Use scientific notation to float points
	fgir << std::setprecision(8);			//Default precision for float points

	fgir << "\nSolutionSteps\t" << gm.solution_vector.size() << "\n";
	for (auto&& sol: gm.solution_vector)
		sol->WriteGiraffeFile(fgir);

	fgir << "\nMonitor\n" << gm.monitor 
		 << "\nPostFiles\n" << &gm.post
		 << "\nSolverOptions\n" << &gm.gir_solver;

	fgir << "\nConvergenceCriteria\n" << gm.gir_solver.GetConvCriteria();

	fgir << "\nNodeSets\t" << gm.node_set_vector.size() << "\n";
	for (const NodeSet& ns : gm.node_set_vector)
		fgir << ns;

	fgir << "\nPipeSections\t" << gm.pipe_section_vector.size() << "\n";
	for (const PipeSection& section : gm.pipe_section_vector)
		fgir << section;

	fgir << "\nRigidBodyData\t" << gm.rbdata_vector.size();
	for (const RigidBodyData& rb_data : gm.rbdata_vector)
		fgir << rb_data;
	fgir << "\n";

	if ( !gm.post.GetAllCADs().empty() )
	{
		fgir << "\nCADData\t" << gm.post.GetAllCADs().size() << "\n";
		for (const CADData& cad : gm.post.GetAllCADs())
			fgir << cad;
	}

	fgir << "\nConstraints\t" << gm.constraint_vector.size() << "\n";
	for (auto&& constraint : gm.constraint_vector)
		constraint->WriteGiraffeFile(fgir);

	fgir << "\nEnvironment\n" << gm.environment;

	fgir << "\nContacts\t" << gm.contact_vector.size() << "\n";
	for (auto&& contact : gm.contact_vector)
		contact->WriteGiraffeFile(fgir);

	fgir << "\nSurfaces\t" << gm.oscillatory_vector.size() << "\n";
	for (const OscillatorySurf& surface : gm.oscillatory_vector)
		fgir << surface;

	fgir << "\nSurfaceSets\t" << gm.surface_set_vector.size() << "\n";
	for (const SurfaceSet& surface_set : gm.surface_set_vector)
		fgir << surface_set;

	fgir << "\nCoordinateSystems\t" << gm.cs_vector.size() << "\n";
	for (const CoordinateSystem& coord_system : gm.cs_vector)
		fgir << coord_system;

	fgir << "\nSpecialConstraints\t" << gm.special_constraint_vector.size() << "\n";
	for (auto&& special_constraint : gm.special_constraint_vector )
		special_constraint->WriteGiraffeFile(fgir);

	fgir << "\n\nElements\t" << gm.element_vector.size() << "\n";
	for (auto&& element : gm.element_vector)
		element->WriteGiraffeFile(fgir);
	
	fgir << "\nNodes\t" << gm.node_vector.size() << "\n";
	for (const Node& node : gm.node_vector)
		fgir << node;

	//Chenge precision for displacements and loads
	fgir << std::setprecision(16);

	fgir << "\nDisplacements\t" << gm.displacement_vector.size() << "\n";
	for (auto&& disp : gm.displacement_vector)
		disp->WriteGiraffeFile(fgir);

	if ( !gm.load_vector.empty() )
	{
		fgir << "\nLoads\t" << gm.load_vector.size() << "\n";
		for (auto&& load : gm.load_vector)
			load->WriteGiraffeFile(fgir);
	}

	fgir.close();
}
