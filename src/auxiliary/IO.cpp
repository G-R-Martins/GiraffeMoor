#include "PCH.h"
#include "IO.h"
// Database headers
#include "MooringModel.h"
#include "GiraffeModel.h"
// Auxiliary namespace headers
#include "AuxFunctions.h"
#include "Log.h"

// Header file generated by CMake with some settings
#include "GiraffeMoorConfig.h"

// Global objects
extern MooringModel mm;
extern GiraffeModel gm;


namespace aux_read = AuxFunctions::Reading;


// Static variables

std::string IO::folder_name, IO::input_name, IO::name;
std::ifstream IO::s_inp;

std::string IO::version = std::to_string(GiraffeMoor_VERSION_MAJOR)
	/*-- The following option to check and introduce '0' if n < 10 is quite inefficient, but one of the shortest ways to do it --*/
	+ "." + std::string(2 - std::to_string(GiraffeMoor_VERSION_MINOR).length(), '0') + std::to_string(GiraffeMoor_VERSION_MINOR) 
	+ "." + std::string(2 - std::to_string(GiraffeMoor_VERSION_PATCH).length(), '0') + std::to_string(GiraffeMoor_VERSION_PATCH) 
	+ "-a ";


//MAP_FUNC{{ "Analytical", &IO::ReadAnalyticalStiffnessMatrix }, { "Numerical", &IO::ReadNumericalStiffnessMatrix }}




//Reads GiraffeMoor input file
bool IO::ReadFile()
{	
	std::cout << " ______________________________________________________________ \n";
	std::cout << "|                                                              |\n";
	std::cout << "|                        GiraffeMoor                           |\n";
	std::cout << "|               University of Sao Paulo - Brazil               |\n";
	std::cout << "|                                                              |\n";
	std::cout << "|                                                v. " << IO::version << " |\n";
	std::cout << "|______________________________________________________________|\n\n";
	

	//while (true)
	//{
	//	if (__argc > 1)
	//	{
	//		//passed only the input file name (solution folder in the same location of the executable)
	//		if (__argc == 2)
	//		{ 
	//			input_name = __argv[1]; 
	//			folder_name = "./" + input_name + "/"; 
	//		}
	//		//passed the folder name and the input file name
	//		else if (__argc == 3)	
	//		{ 
	//			input_name = __argv[2]; 
	//			folder_name = std::string(__argv[1]) + input_name + "/"; 
	//		}
	//		else
	//			std::cerr << "invalid number of arguments passed to GiraffeMoor"; std::exit( EXIT_FAILURE );
	//	}
	//	else
	//	{
	//		std::cout << "Enter the name of the input file: ";
	//		std::getline(std::cin, input_name);
	//		
	//		//folder in the same location of the executable
	//		folder_name = "./" + input_name + "/";
	//	}
	//
	//
	//	name = folder_name + input_name + ".gmr";
	//
	//	std::cout << "\n";
	//	
	//	//tries to read the same location of the executable file of Giraffe
	//	s_inp.open(name);
	//	if (!s_inp.is_open())
	//	{
	//		folder_name = "C:/Users/Public/Documents/GiraffeMoor/";
	//		
	//		//checks if there isn't a 'GiraffeMoor' folder in public documents
	//		if (!std::filesystem::is_directory(folder_name))
	//			std::filesystem::create_directory(folder_name);
	//
	//		name = folder_name + input_name + ".gmr";
	//		s_inp.open(name);
	//		if (!s_inp.is_open())
	//			std::cout << "Error reading the input file. Try again.\n";
	//		else
	//			break;
	//	}
	//	else
	//	{
	//		if ( __argc > 1 )
	//			std::cout << "Running file \"" << input_name << ".gmr\" . . .\n\n\n";
	//		break;
	//	}
	//}



	std::string file_name = "oc4.gmr";
	s_inp.open(file_name);
	if (!s_inp.is_open())
	{
		Log::AddError(std::string("Error trying to open the file \"") + file_name + "\"");
		return false;
	}

	std::string word;
	s_inp >> word;

	while (s_inp.good())
	{
		// Check for top level keyword...
		if (!aux_read::CheckTopKeyword(word))
		{
			// ... if isn't, check if is a comment (line or block) ...
			if (aux_read::TryComment(s_inp, word))
				continue;
			
			std::cout << "\"" << word << "\" is not a valid keyword or it has been already defined.";
			std::cout << "\nulitma linha: " << aux_read::GetCurrentLine(s_inp) << "\n";

			return false;
		}


		if (word == "Keypoints")
		{
			if (!aux_read::Loop(s_inp, mm.keypoint_vector, word, 
				MAP_FUNC{ { "Keypoint", &IO::ReadKeypoint } }))
				std::cout << "\nErro lendo Keypoints! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			aux_read::RemoveDuplicates(mm.keypoint_vector, "Keypoint");
		}
		else if (word == "SegmentSets")
		{
			if (!aux_read::Loop(s_inp, mm.segment_set_vector, word, 
				MAP_FUNC{ { "Set", &IO::ReadSegmentSet } }))
				std::cout << " Erro lendo SegmentSets! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			aux_read::RemoveDuplicates(mm.segment_set_vector, "Set");
		}
		else if (word == "Lines")
		{
			if (!aux_read::Loop(s_inp, mm.line_vector, word, 
				MAP_FUNC{ { "Line", &IO::ReadLine }, { "Cable", &IO::ReadLine } }))
				std::cout << "\nErro lendo Lines! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			aux_read::RemoveDuplicates(mm.line_vector, "Line");
		}
		else if (word == "Vessels")
		{
			if (!aux_read::Loop(s_inp, mm.vessel_vector, word, 
				MAP_FUNC{ { "Vessel", &IO::ReadVessel } }))
				std::cout << "\nErro lendo Vessels! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			aux_read::RemoveDuplicates(mm.vessel_vector, "Vessel");
		}
		else if (word == "Environment")
		{
			if (!aux_read::UniqueSubKeywords(s_inp, word, MAP_FUNC{ { "General", &IO::ReadEnvGeneral}, 
					{ "Seabed", &IO::ReadSeabed}, { "SeaCurrent", &IO::ReadSeaCurrent} }))
				std::cout << "\nErro lendo Environment! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura
		}
		else if (word == "SegmentProperties")
		{
			if (!aux_read::Loop(s_inp, mm.segment_property_vector, word, 
				MAP_FUNC{ { "SegmentProperty", &IO::ReadSegmentProperty} }))
				std::cout << "\nErro lendo SegmentProperties! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			aux_read::RemoveDuplicates(mm.segment_property_vector, "SegmentProperty");
		}
		else if (word == "Solution")
		{
			if (!aux_read::UniqueSubKeywords(s_inp, word, MAP_FUNC{ 
					{ "DynamicRelaxation", &IO::ReadDynamicRelaxation},
					{ "SeaCurrentStep", &IO::ReadSeaCurrentStep},
					{ "Analysis", &IO::ReadAnalysis} 
				}))
				std::cout << "\nErro lendo Solution! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura
			
			aux_read::RemoveDuplicates(mm.moorsolution.GetStepsVec(), "SolutionSteps");
		}
		else if (word == "Constraints")
		{
			if (!aux_read::UniqueSubKeywords(s_inp, word, MAP_FUNC{ 
					{ "AnchorConstraints", &IO::ReadConstraints },
					{ "LineConstraints", &IO::ReadConstraints },
					{ "VesselConstraints", &IO::ReadConstraints } 
				}))
				std::cout << "\nErro lendo Solution! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			aux_read::RemoveDuplicates(mm.anchor_constraints, "AnchorConstraints");
			aux_read::RemoveDuplicates(mm.line_constraints, "LineConstraints");
			aux_read::RemoveDuplicates(mm.vessel_constraints, "VesselConstraints");
		}
		else if (word == "VesselDisplacements")
		{
			if (!aux_read::Loop(s_inp, mm.vessel_disp_vector, word, 
				MAP_FUNC{ { "DispVesselID", &IO::ReadVesselDisplacement } }))
				std::cout << "\nErro lendo VesselDisplacements! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			aux_read::RemoveDuplicates(mm.vessel_disp_vector, "VesselDisplacements");
		}
		else if (word == "GiraffeSolver")
		{
			if (!aux_read::UniqueSubKeywords(s_inp, word, MAP_FUNC{
					{ "Run", &IO::ReadRunOption }, { "Processors", &IO::ReadProcessors },
					{ "ConvergenceCriteria", &IO::ReadConvergenceCriteria } 
				}))
				std::cout << "\nErro lendo Solution! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura
		}
		else if (word == "PostProcessing")
		{
			if (!aux_read::UniqueSubKeywords(s_inp, word,
				MAP_FUNC{ { "PostFiles", &IO::ReadPostFiles }, { "CADs", &IO::ReadCADs } }))
				std::cout << "\nErro lendo PostProcessing! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			if (!mm.moorpost.GetAllPlatformCADs().empty())
				aux_read::RemoveDuplicates(mm.moorpost.GetAllPlatformCADs(), "VesselDisplacements");
		}
		else if (word == "DisplacementFields")
		{
			if (!IO::ReadLineDisplacementFields(word))
				std::cout << "\nErro lendo DisplacementFields! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura

			aux_read::RemoveDuplicates(mm.disp_field_vector, "VesselDisplacements");
		}
		else
		{
			std::cout << "\nErro lendo linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura
		}


	} /* end while */

	return true;
}


bool IO::ReadKeypoint(std::string& readed)
{
	// Get last allocated object
	Keypoint* keypoint = &mm.keypoint_vector.back();

	std::unordered_set<std::string_view> names{ "X", "Y", "Z" };
	double num;

	// Read the ID number
	s_inp >> readed;
	size_t num_ID = aux_read::Try2GetObjectID<size_t>(s_inp, readed);
	keypoint->SetIDNumber(num_ID);

	s_inp >> readed;
	
	do {
		// Extract node (handle) from set with names of the object parameters
		auto nh = names.extract(readed);
		if (nh.empty())
		{
			bool all_parameters_readed = names.empty();
			if (!all_parameters_readed)
				Log::AddWarning(Log::Warning::INVALID_ID, "Keypoint", aux_read::GetCurrentLine(s_inp));

			return all_parameters_readed;
		}

		std::string_view name = nh.value();
		s_inp >> num;

		if (name == "X")		keypoint->SetX(num);
		else if (name == "Y")	keypoint->SetY(num);
		else if (name == "Z")	keypoint->SetZ(num);

		s_inp >> readed;

	} while (!names.empty());
	
	// All OK while reading
	return true;
}

bool IO::ReadSegmentSet(std::string& readed)
{
	// Get last allocated object
	SegmentSet* set = &mm.segment_set_vector.back();
	
	std::unordered_set<std::string_view> upper_keywords{ "Set" };

	// Read the ID number
	s_inp >> readed;
	size_t num_ID = aux_read::Try2GetObjectID<size_t>(s_inp, readed);
	set->SetIDNumber(num_ID);

	if (!aux_read::NestedLoop(s_inp, set->GetAllSegment(), upper_keywords, readed, 
		MAP_FUNC{ { "Length", &IO::ReadSegment } }))
		std::cout << "\nErro lendo SegmentSets"; // TODO: verificar erro leitura
	

	// All OK while reading
	return true;
}
bool IO::ReadSegment(std::string& readed)
{
	// Get last allocated object
	LineSegment* seg = &mm.segment_set_vector.back().GetLastSegment();
	
	std::unordered_set<std::string_view> names{ "Length", "Property", "Discretization" };

	do {
		// Extract node (handle) from set with names of the object parameters
		auto nh = names.extract(readed);
		if (nh.empty()) // invalid property
		{ 
			// If is not a valid node handle, then check if all parameters were defined
			bool all_parameters_readed = names.empty();
			if (!all_parameters_readed)
				Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Segment", std::to_string(aux_read::GetCurrentLine(s_inp)) });

			return all_parameters_readed;
		}

		std::string_view name = nh.value();
		s_inp >> readed;

		if (name == "Length")				seg->SetLength(std::stod(readed));
		else if (name == "Property")		seg->SetProperty(std::stoul(readed));
		else if (name == "Discretization")	seg->SetDiscretization(std::stoul(readed));

		s_inp >> readed;

	} while (true);


	// All OK while reading
	return true;
}

bool IO::ReadLine(std::string& readed)
{
	// Get last allocated object
	Line* line = &mm.line_vector.back();

	std::unordered_set<std::string_view> names;

	size_t num;

	// Read the ID number
	s_inp >> readed;
	size_t num_ID = aux_read::Try2GetObjectID<size_t>(s_inp, readed);
	line->SetIDNumber(num_ID);

	s_inp >> readed;

	// If is shared, one MUST define "Fairleads" or "VesselIDs" after the ID number
	// thus, it CAN NOT be "SegmentSet" in this case!
	if (name == "Fairleads" || name == "VesselIDs")
	{
		names = { "Fairleads", "VesselIDs", "SegmentSet" };
		line->SetSharedOpt(true);
	}
	else
		names = { "Anchor", "Fairlead", "VesselID", "SegmentSet" };

	do {
		// Extract node (handle) from set with names of the object parameters
		auto nh = names.extract(readed);
		if (nh.empty())
		{
			bool all_parameters_readed = names.empty();
			if (!all_parameters_readed)
				Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Keypoint", std::to_string(aux_read::GetCurrentLine(s_inp)) });

			return all_parameters_readed;
		}

		std::string_view name = nh.value();
		s_inp >> num;

		if (name == "Anchor") { line->SetKeypointA(num); }
		else if (name == "Fairlead") { line->SetKeypointB(num); }
		else if (name == "VesselID") { line->SetVesselID(num); }
		else if (name == "SegmentSet") { line->SetSegmentSet(num); }
		// Shared line
		else if (name == "Fairleads")
		{
			// First fairlead
			line->SetKeypointA(num);

			// Separator
			char ch = s_inp.get();
			if (ch != ',' && ch != ';')
				return false;

			// Second fairlead
			s_inp >> num;
			line->SetKeypointB(num);
		}
		else if (name == "VesselIDs")
		{
			// First vessel
			line->SetVesselID(num);

			// Separator
			char ch = s_inp.get();
			if (ch != ',' && ch != ';')
				return false;

			// Second vessel
			s_inp >> num;
			line->SetVesselID(num);
		}

		s_inp >> readed;

	} while (!names.empty());

	// All OK while reading
	return true;
}

bool IO::ReadVessel(std::string& readed)
{
	//Get last allocated object
	Vessel* vessel = &mm.vessel_vector.back();

	std::unordered_set<std::string_view> mandatory{ "PilotNode" };
	std::unordered_set<std::string_view> optional{ "InertiaTensor", "Mass" };
	
	// Read the ID number
	s_inp >> readed;
	size_t num_ID = aux_read::Try2GetObjectID<size_t>(s_inp, readed);
	vessel->SetIDNumber(num_ID);

	do {
		s_inp >> readed;

		// Tries to extract node (handle) from set with mandatory names ...
		auto nh = mandatory.extract(readed);
		if (nh.empty())
		{
			// ... if fails, try from optional names ...
			nh = optional.extract(readed);
			// ... then, check for error and other words
			if (nh.empty())
			{
				bool all_parameters_readed = mandatory.empty();
				if (!all_parameters_readed)
					Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Vessel", std::to_string(aux_read::GetCurrentLine(s_inp)) });
				
				return all_parameters_readed;
			}
		}

		std::string_view name = nh.value();
		
		if (name == "InertiaTensor")
		{
			vessel->SetInertiaTensor(aux_read::ReadFixedContainer<std::array<float, 6>, 6>(s_inp));
			continue;
		}

		s_inp >> readed;

		if (name == "PilotNode")	vessel->SetNode(std::stoul(readed));
		else if (name == "Mass")	vessel->SetMass(std::stof(readed));

	} while (true);


	// All OK while reading
	return true;
}

bool IO::ReadDynamicRelaxation(std::string& readed)
{
	if (!aux_read::UniqueSubKeywords(s_inp, readed, 
		MAP_FUNC{ { "LineStatics", &IO::ReadDynRelaxLines }, { "VesselStatics", &IO::ReadDynRelaxVessels} }))
	{
		std::cout << "\nErro lendo DynamicRelaxation! Linha " << aux_read::GetCurrentLine(s_inp) << "\n"; // TODO: verificar erro leitura
		return false;
	}


	// All OK while reading
	return true;
}
bool IO::ReadDynRelaxLines(std::string& readed)
{
	//Get last allocated object
	auto& relax = mm.moorsolution.GetStepDynRelaxLines();
	relax = std::make_shared<DynRelaxLinesConfig>(0.0, 0, 0, 0, false, true, 0.0, 0.0, 1.0, 1.0e-1, 1.0e-4, 1'000'000,
		0.0, 0.0, 0.0, 0.0);

	std::unordered_set<std::string_view> mandatory{ "Decrement", "Periods"};
	std::unordered_set<std::string_view> optional{ "TimeStep", "MaxTimeStep", "MinTimeStep", "Sample" };
	
	relax->SetDynamicOpt(true);
	relax->SetStaticOpt(false);

	do {
		s_inp >> readed;

		// Tries to extract node (handle) from set with mandatory names ...
		auto nh = mandatory.extract(readed);
		if (nh.empty())
		{
			// ... if fails, try from optional names ...
			nh = optional.extract(readed);
			// ... then, check for error and other words
			if (nh.empty())
			{
				bool all_parameters_readed = mandatory.empty();
				if (!all_parameters_readed)
					Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "DynamicRelaxation", std::to_string(aux_read::GetCurrentLine(s_inp)) });

				return all_parameters_readed;
			}
		}

		std::string_view name = nh.value();

		s_inp >> readed;

		if (name == "Decrement")			relax->SetDecrement(std::stod(readed));
		else if (name == "Periods")			relax->SetPeriods(std::stoul(readed));
		else if (name == "TimeStep")		relax->SetTimestep(std::stod(readed));
		else if (name == "MaxTimeStep")		relax->SetMaxTimestep(std::stod(readed));
		else if (name == "MinTimeStep")		relax->SetMinTimeStep(std::stod(readed));
		else if (name == "Sample")			relax->SetSample(std::stoi(readed));

	} while (true);


	// All OK while reading
	return true;
}
bool IO::ReadDynRelaxVessels(std::string& readed)
{
	// Get and initialize the step object
	auto& relax = mm.moorsolution.GetStepDynRelaxVessels();
	relax = std::make_shared<SolutionStep>(0, false, true, 0.0, 0.0, 1.0, 1.0e-1, 1.0e-4, 1'000'000,
		0.0, 0.0, 0.0, 0.0);

	std::unordered_set<std::string_view> mandatory{ "Time" };
	std::unordered_set<std::string_view> optional{ "TimeStep", "MaxTimeStep", "MinTimeStep", "Sample" };


	do {
		s_inp >> readed;

		// Tries to extract node (handle) from set with mandatory names ...
		auto nh = mandatory.extract(readed);
		if (nh.empty())
		{
			// ... if fails, try from optional names ...
			nh = optional.extract(readed);
			// ... then, check for error and other words
			if (nh.empty())
			{
				bool all_parameters_readed = mandatory.empty();
				if (!all_parameters_readed)
					Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "DynamicRelaxation", std::to_string(aux_read::GetCurrentLine(s_inp)) });

				return all_parameters_readed;
			}
		}

		std::string_view name = nh.value();

		s_inp >> readed;

		if (name == "Time")					relax->SetEndTime(std::stod(readed));
		else if (name == "TimeStep")		relax->SetTimestep(std::stod(readed));
		else if (name == "MaxTimeStep")		relax->SetMaxTimestep(std::stod(readed));
		else if (name == "MinTimeStep")		relax->SetMinTimeStep(std::stod(readed));
		else if (name == "Sample")			relax->SetSample(std::stoi(readed));

	} while (true);


	// All OK while reading
	return true;
}
bool IO::ReadSeaCurrentStep(std::string& readed)
{
	// Get and initialize the step object
	mm.moorsolution.SetStepSeaCurrent(0,true, false, 0.0, 0.0, 1.0, 1.0, 1.0e-5, 1'000'000,
		0.0, 0.0, 0.0, 0.0);
	auto& sc = mm.moorsolution.GetStepSeaCurrent();
	
	std::unordered_set<std::string_view> mandatory{ "Time" };
	std::unordered_set<std::string_view> optional{ "TimeStep", "MaxTimeStep", "MinTimeStep", "Sample" };
	
	sc->SetStaticOpt(true);
	sc->SetDynamicOpt(false);

	do {
		s_inp >> readed;

		// Tries to extract node (handle) from set with mandatory names ...
		auto nh = mandatory.extract(readed);
		if (nh.empty())
		{
			// ... if fails, try from optional names ...
			nh = optional.extract(readed);
			// ... then, check for error and other words
			if (nh.empty())
			{
				bool all_parameters_readed = mandatory.empty();
				if (!all_parameters_readed)
					Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "SeaCurrentStep", std::to_string(aux_read::GetCurrentLine(s_inp)) });

				return all_parameters_readed;
			}
		}

		std::string_view name = nh.value();

		s_inp >> readed;

		if (name == "Time")					sc->SetEndTime(std::stod(readed));
		else if (name == "TimeStep")		sc->SetTimestep(std::stod(readed));
		else if (name == "MaxTimeStep")		sc->SetMaxTimestep(std::stod(readed));
		else if (name == "MinTimeStep")		sc->SetMinTimeStep(std::stod(readed));
		else if (name == "Sample")			sc->SetSample(std::stoi(readed));

	} while (true);


	// All OK while reading
	return true;
}
bool IO::ReadAnalysis(std::string& readed)
{
	std::unordered_set<std::string_view> upper_keywords{"SeaCurrentStep", "DynamicRelaxation" };

	if (!aux_read::NestedLoop(s_inp, mm.moorsolution.GetStepsVec(),
		upper_keywords, readed, MAP_FUNC{ { "Step", &IO::ReadSolutionStep} }))
		std::cout << "\nErro lendo SegmentSets"; // TODO: verificar erro leitura


	// All OK while reading
	return true;
}
bool IO::ReadSolutionStep(std::string& readed)
{
	//Get last allocated object
	SolutionStep* step = &mm.moorsolution.GetStepsVec().back();

	// Sets with keywords 
	std::unordered_set<std::string_view> mandatory, optional, invalid;
	
	// Read the ID number
	s_inp >> readed;
	size_t num_ID = aux_read::Try2GetObjectID<size_t>(s_inp, readed);
	step->SetIDNumber(num_ID);
	
	// Read solution type 
	s_inp >> readed;
	if (readed == "static")
	{
		mandatory = { "Time", "TimeStep", "MinTimeStep", "Sample"};
		optional = { "MaxTimeStep" };
		invalid = { "NumericalDamping", "RayleighDamping"};
	}
	else if (readed == "dynamic")
	{
		mandatory = { "Time", "TimeStep", "MinTimeStep", "Sample", "NumericalDamping" };
		optional = { "MaxTimeStep", "RayleighDamping" };
		invalid = { };
	}
	else
	{
		Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Solution step", std::to_string(aux_read::GetCurrentLine(s_inp)) });
		return false;
	}


	do {
		s_inp >> readed;

		// Tries to extract node (handle) from set with mandatory names ...
		auto nh = mandatory.extract(readed);
		if (nh.empty())
		{
			// ... if fails, try from optional names ...
			nh = optional.extract(readed);
			// ... then, check for error and other words
			if (nh.empty())
			{
				bool all_parameters_readed = mandatory.empty();
				if (!all_parameters_readed)
					Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Solution step", std::to_string(aux_read::GetCurrentLine(s_inp)) });

				return all_parameters_readed;
			}
		}

		std::string_view name = nh.value();

		s_inp >> readed;

		if (name == "Time")						step->SetEndTime(std::stod(readed));
		else if (name == "TimeStep")			step->SetTimestep(std::stod(readed));
		else if (name == "MaxTimeStep")			step->SetMaxTimestep(std::stod(readed));
		else if (name == "MinTimeStep")			step->SetMinTimeStep(std::stod(readed));
		else if (name == "Sample")				step->SetSample(std::stoi(readed));
		else if (name == "NumericalDamping")	step->SetNewmarkDamping(readed);
		else if (name == "RayleighDamping")
		{
			// Read two coefficients
			for (int cont = 1; cont <= 2; ++cont)
			{
				s_inp >> readed;
				if (readed == "Alpha")
				{
					s_inp >> readed;
					step->SetAlphaRayleigh(std::stod(readed));
				}
				else if (readed == "Beta")
				{
					s_inp >> readed;
					step->SetBetaRayleigh(std::stod(readed));
				}
				else
				{
					// The user can define only one coefficient
					// 
					// PS: if the user define only the keyword "RayleighDamping" and 
					// and any coefficient, default (null) values will be considered
					return mandatory.empty();
				}
			}
		}

	} while (true);


	// All OK while reading
	return true;
}

bool IO::ReadSegmentProperty(std::string& readed)
{
	// Get last allocated object
	SegmentProperty* prop = &mm.segment_property_vector.back();

	std::unordered_set<std::string_view> mandatory, optional, invalid;
	double num;

	// Read the ID number
	s_inp >> readed;
	size_t num_ID = aux_read::Try2GetObjectID<size_t>(s_inp, readed);
	prop->SetIDNumber(num_ID);

	// Check segment type
	s_inp >> readed;
	if (readed == "truss")
	{
		prop->SetTrussOpt(true);
		mandatory = { "SpecificMass", "Diameter", "EA", "CDt", "CDn", "CAt", "CAn" };
		optional = { "SpecificGravity", "YoungModulus", "PoissonRatio", "InnerDiameter", "ContactDiameter" };
		invalid = { "EI", "GJ", "GA" };
	}
	else if (readed == "beam")
	{
		prop->SetBeamOpt(true);
		mandatory = { "SpecificMass", "Diameter", "EA", "CDt", "CDn", "CAt", "CAn", "EI", "GJ", "GA" };
		optional = { "SpecificGravity", "YoungModulus", "PoissonRatio", "InnerDiameter", "ContactDiameter" };
		invalid = {};
	}
	else if (readed == "chain")
	{
		prop->SetChainOpt(true);
		mandatory = { "MBS" };
		optional = {};
		invalid = { "SpecificGravity", "SpecificMass", "Diameter" , "ContactDiameter", 
			"InnerDiameter", "EA", "EI", "GA", "GJ", "CDt", "CDn", "CAt", "CAn" };
	}
	else
	{
		Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "SegmentProperty", std::to_string(aux_read::GetCurrentLine(s_inp)) });
		return false;
	}

	// Read properties
	do {
		s_inp >> readed;

		// Tries to extract node (handle) from set with mandatory names ...
		auto nh = mandatory.extract(readed);
		if (nh.empty())
		{
			// ... if fails, try from optional names ...
			nh = optional.extract(readed);
			// ... then, check for error and other words
			if (nh.empty())
			{
				bool all_parameters_readed = mandatory.empty();
				if (!all_parameters_readed)
					Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "SegmentProperty", std::to_string(aux_read::GetCurrentLine(s_inp)) });

				return all_parameters_readed;
			}
		}

		std::string_view name = nh.value();

		s_inp >> num;
				
		if (name == "SpecificGravity")			prop->SetSG(num);
		else if (name == "SpecificMass")		prop->SetMass(num);
		else if (name == "Diameter")			prop->SetDiameter(num);
		else if (name == "ContactDiameter")		prop->SetContactDiameter(num);
		else if (name == "InnerDiameter")		prop->SetInnerDiameter(num);
		else if (name == "EA")					prop->SetEA(num);
		else if (name == "EI")					prop->SetEI(num);
		else if (name == "GA")					prop->SetGA(num);
		else if (name == "GJ")					prop->SetGJ(num);
		else if (name == "CDt")					prop->SetCDt(num);
		else if (name == "CDn")					prop->SetCDn(num);
		else if (name == "CAt")					prop->SetCAt(num);
		else if (name == "CAn")					prop->SetCAn(num);
		else if (name == "MBS")					prop->SetMBS(num);

	} while (true);

	// All OK while reading
	return true;
}

bool IO::ReadEnvGeneral(std::string& readed)
{
	// Get last allocated object
	MoorEnvironment* environment = &mm.environment;

	std::unordered_set<std::string_view> names{ "Gravity", "RhoFluid", "WaterDepth" };
	double num;

	s_inp >> readed;
	do {
		// Extract node (handle) from set with names of the object parameters
		auto nh = names.extract(readed);
		if (nh.empty())
		{
			bool all_parameters_readed = names.empty();
			if (!all_parameters_readed)
				Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Environment general properties", std::to_string(aux_read::GetCurrentLine(s_inp)) });

			return all_parameters_readed;
		}

		std::string_view name = nh.value();
		s_inp >> num;

		if (name == "Gravity")			environment->SetGravity(num);
		else if (name == "RhoFluid")	environment->SetRhoFluid(num);
		else if (name == "WaterDepth")	environment->SetWaterDepth(num);

		s_inp >> readed;

	} while (!names.empty());


	// All OK while reading
	return true;
}
bool IO::ReadSeabed(std::string& readed)
{
	// Get last allocated object
	Seabed* seabed = &mm.environment.GetSeabed();

	std::unordered_set<std::string_view> names{ "Stiffness", "Damping", "FrictionCoefficient" };
	double num;

	// Read seabed type (for now, it MUST be "flat")
	s_inp >> readed;
	if (readed == "flat")
		seabed->SetFlatOption(true);
	else
	{
		Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Seabed", std::to_string(aux_read::GetCurrentLine(s_inp)) });
		return false;
	}

	s_inp >> readed;
	do {
		// Extract node (handle) from set with names of the object parameters
		auto nh = names.extract(readed);
		if (nh.empty())
		{
			bool all_parameters_readed = names.empty();
			if (!all_parameters_readed)
				Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Seabed", std::to_string(aux_read::GetCurrentLine(s_inp)) });

			return all_parameters_readed;
		}

		std::string_view name = nh.value();
		s_inp >> num;

		if (name == "Stiffness")				seabed->SetStiffness(num);
		else if (name == "Damping")				seabed->SetDamping(num);
		else if (name == "FrictionCoefficient")	seabed->SetFrictionCoefficient(num);

		s_inp >> readed;

	} while (!names.empty());


	// All OK while reading
	return true;
}
bool IO::ReadSeaCurrent(std::string& readed)
{
	std::unordered_set<std::string_view> upper_keywords{ "Seabed", "General"};

	if (!aux_read::NestedLoop(s_inp, mm.environment.GetSeaCurrentVec(),
		upper_keywords, readed, MAP_FUNC{ { "Depth", &IO::ReadSeaCurrentAt } }))
		std::cout << "\nErro lendo SeaCurrent"; // TODO: verificar erro leitura


	// All OK while reading
	return true;
}
bool IO::ReadSeaCurrentAt(std::string& readed)
{
	// Get last allocated object
	SeaCurrent* sc = &mm.environment.GetSeaCurrentVec().back();

	std::unordered_set<std::string_view> names{ "Azimuth", "Speed", "Depth" };
	double num;

	do {
		// Extract node (handle) from set with names of the object parameters
		auto nh = names.extract(readed);
		if (nh.empty())
		{
			bool all_parameters_readed = names.empty();
			if (!all_parameters_readed)
				Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Sea current", std::to_string(aux_read::GetCurrentLine(s_inp)) });

			return all_parameters_readed;
		}

		std::string_view name = nh.value();
		s_inp >> num;

		if (name == "Depth")			sc->SetDepth(num);
		else if (name == "Speed")		sc->SetSpeed(num);
		else if (name == "Azimuth")		sc->SetAzimuth(num);

		s_inp >> readed;

	} while (!names.empty());


	// All OK while reading
	return true;
}

bool IO::ReadRunOption(std::string& readed)
{
	bool option;
	
	s_inp >> std::boolalpha;
	s_inp >> option;
	gm.gir_solver.SetRunGiraffeOpt(option);
	
	
	s_inp >> std::noboolalpha;
	s_inp >> readed;
	
	// All OK while reading
	return true;
}
bool IO::ReadProcessors(std::string& readed)
{
	auto* solver = &gm.gir_solver;

	std::unordered_set<std::string_view> names{ "Cores", "LinSys" };

	do {
		s_inp >> readed;

		// Extract node (handle) from set with names of the object parameters
		auto nh = names.extract(readed);
		if (nh.empty())
		{
			bool all_parameters_readed = names.empty();
			if (!all_parameters_readed)
				Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "Solver", std::to_string(aux_read::GetCurrentLine(s_inp)) });

			return all_parameters_readed;
		}

		std::string_view name = nh.value();
		s_inp >> readed;

		if (name == "Cores")		solver->SetCores(std::stoul(readed));
		else if (name == "LinSys")	solver->SetLinSolverOpt(readed);

	} while (true);


	// All OK while reading
	return true;
}
bool IO::ReadConvergenceCriteria(std::string& readed)
{
	auto* conv_criteria = &gm.gir_solver.GetConvCriteria();

	std::unordered_set<std::string_view> names{ "ForceTolerance", "MomentTolerance", "ForceMinimumReference", "MomentMinimumReference",
		"ConstraintMinimumReference", "DisplacementTolerance", "RotationTolerance", "LagrangeTolerance",
		"DisplacementMinimumReference", "RotationMinimumReference", "LagrangeMinimumReference", "DivergenceReference" };

	double num;

	do {
		aux_read::TryCommentAndContinue(s_inp, readed);

		// Extract node (handle) from set with names of the object parameters
		auto nh = names.extract(readed);
		if (nh.empty())
			break;

		std::string_view name = nh.value();
		s_inp >> num;

		if (name == "ForceTolerance")						conv_criteria->force_tol = num;
		else if (name == "MomentTolerance")					conv_criteria->moment_min = num;
		else if (name == "ForceMinimumReference")			conv_criteria->force_min = num;
		else if (name == "MomentMinimumReference")			conv_criteria->moment_min = num;
		else if (name == "ConstraintMinimumReference")		conv_criteria->constraint_min = num;
		else if (name == "DisplacementTolerance")			conv_criteria->disp_tol = num;
		else if (name == "RotationTolerance")				conv_criteria->rot_tol = num;
		else if (name == "LagrangeTolerance")				conv_criteria->lag_tol = num;
		else if (name == "DisplacementMinimumReference")	conv_criteria->disp_min = num;
		else if (name == "RotationMinimumReference")		conv_criteria->rot_min = num;
		else if (name == "LagrangeMinimumReference")		conv_criteria->lag_min = num;
		else if (name == "DivergenceReference")				conv_criteria->divergence_ref = num;

	} while (true);


	// All OK while reading
	return true;
}

bool IO::ReadPostFiles(std::string& readed)
{
	WritingFlags* flags = &mm.moorpost.GetWritingFlags();
	
	std::unordered_set<std::string_view> names{ "None", "Mesh", "RenderMesh", 
		"RigidContactSurfaces", "FlexibleContactSurfaces", 
		"Constraints", "Forces", "SpecialConstraints", "ContactForces", 
		"RenderParticles", "RenderRigidBodies" };

	do {
		s_inp >> readed;

		// Extract node (handle) from set with names of the object parameters
		if (names.extract(readed).empty())
			break;

		if (readed == "None")
		{ 
			flags->SetAllFlags(false);
			return true; 
		}
		else if (readed == "RenderRigidBodies")			flags->SetRenderRigidBodiesFlag(true);
		else if (readed == "Forces")					flags->SetForcesFlag(true);
		else if (readed == "ContactForces")				flags->SetContactForcesFlag(true);
		else if (readed == "RigidContactSurfaces")		flags->SetRigidContactSurfacesFlag(true);
		else if (readed == "RenderMesh")				flags->SetRenderMeshFlag(true);
		else if (readed == "Constraints")				flags->SetConstraintsFlag(true);
		else if (readed == "SpecialConstraints")		flags->SetSpecialConstraintsFlag(true);
		else if (readed == "Mesh")						flags->SetMeshFlag(true);
		else if (readed == "FlexibleContactSurfaces")	flags->SetFlexibleContactSurfacesFlag(true);
		else if (readed == "RenderParticles")			flags->SetRenderParticlesFlag(true);
		else if (readed == "All")						flags->SetAllFlags(true);

	} while (true);


	// All OK while reading
	return true;
}
bool IO::ReadCADs(std::string& readed)
{
	std::unordered_set<std::string_view> upper_keywords{ "PostFiles" };

	if (!aux_read::NestedLoop(s_inp, mm.moorpost.GetAllPlatformCADs(), upper_keywords, 
		readed, MAP_FUNC{ { "PlatformID", &IO::ReadPlatformCAD } }))
		std::cout << "\nErro lendo PlatformCADs"; // TODO: verificar erro leitura


	// All OK while reading
	return true;
}
bool IO::ReadPlatformCAD(std::string& readed)
{
	// Get last allocated object
	CADData* cad = &mm.moorpost.GetAllPlatformCADs().back();

	// Read the ID number
	s_inp >> readed;
	size_t num_ID = aux_read::Try2GetObjectID<size_t>(s_inp, readed);
	cad->SetIDNumber(num_ID);
	
	// Read name
	s_inp >> readed;
	if (readed != "Name")
	{
		Log::AddWarning(Log::Warning::Invalid_ID, VEC_STR{ "PlatformCAD", std::to_string(aux_read::GetCurrentLine(s_inp)) });
		return false;
	}

	s_inp >> readed;
	cad->SetName(readed);

	// Read next word
	s_inp >> readed;

	// All OK while reading
	return true;
}

bool IO::ReadAnalyticalStiffnessMatrix(std::string& readed)
{
	bool option;

	s_inp >> std::boolalpha >> option;
	mm.stiff_matrix->SetAnalyticalStiffnessOpt(option);

	s_inp >> std::noboolalpha >> readed;

	// All OK while reading
	return true;
}
bool IO::ReadNumericalStiffnessMatrix(std::string& readed)
{
	// TODO: adaptar
	/*if (!strcmp(str, "Numerical"))
	{
		if (fscanf(f, "%s", str) != EOF && (!strcmp(str, "true") || !strcmp(str, "1")))
		{
			bool_num = true;

			if (fscanf(f, "%s %lf", str, &time_matrix) == EOF || strcmp(str, "Time") ||
				fscanf(f, "%s %lf %lf %lf %lf %lf %lf", str, &disp_matrix_x, &disp_matrix_y, &disp_matrix_z,
					&rot_matrix_x, &rot_matrix_y, &rot_matrix_z) == EOF || strcmp(str, "Offsets"))
			{
				Log::AddWarning("\n   + Error reading numerical stiffness matrix data.\n");
				return false;
			}
		}
	}*/
	return false;
}

bool IO::ReadVesselDisplacement(std::string& readed)
{
	VesselDisplacement* disp = &mm.vessel_disp_vector.back();

	bool step_defined = false, disp_type_defined = false;

	// Read the vessel ID 
	s_inp >> readed;
	size_t num_ID = aux_read::Try2GetObjectID<size_t>(s_inp, readed);
	disp->SetVesselID(num_ID);

	s_inp >> readed;

	// Read two coefficients
	for (int aux : {1, 2})
	{
		if (!step_defined && readed == "Step")
		{
			s_inp >> readed;
			disp->SetSolutionStep(std::stoull(readed));
			step_defined = true;
		}
		else if (!disp_type_defined && readed == "TimeSeries")
		{
			disp->SetTimeSeries();
			s_inp >> disp->GetTimeSeries();
			disp_type_defined = true;
		}
		else if (!disp_type_defined && readed == "MathCode")
		{
			disp->SetMathCode();
			s_inp >> disp->GetMathCode();
			disp_type_defined = true;
		}
		else if (!disp_type_defined && readed == "File")
		{
			s_inp >> readed;
			// TODO: ler arquivo externo
			disp_type_defined = true;
		}
		else if (!disp_type_defined && readed == "SineWave")
		{
			s_inp >> readed;
			// TODO: SineWave-like
			disp_type_defined = true;
		}
		else
			return false;

		aux_read::TryCommentAndContinue(s_inp, readed);
	}


	// All OK while reading
	return true;
}

bool IO::ReadLineDisplacementFields(std::string& readed)
{
	// Object pointer
	LineDisplacementField* line{};
	const std::string_view keyword{ "DispLineID" };

	while (true)
	{
		// Searches for keyword
		aux_read::TryCommentAndContinue(s_inp, readed);
		if (readed != keyword)
			break;

		line = &mm.disp_field_vector.emplace_back();

		// Displacement data
		s_inp >> line;
	}

	// All OK while reading
	return true;
}

bool IO::ReadConstraints(std::string& readed)
{
	// Constraint object 
	MoorConstraint* obj{};
	std::string_view keyword;
	
	// Lambda function to create object and return a reference 
	//std::function<MoorConstraint* (void)> emplace_constraint;
	MoorConstraint* (*emplace_constraint)(void) {};

	if (readed == "VesselConstraints")
	{
		keyword = "VesselID";
		emplace_constraint = []() { return &mm.vessel_constraints.emplace_back(); };
	}
	else if (readed == "AnchorConstraints")
	{
		keyword = "LineID";
		emplace_constraint = []() { return &mm.anchor_constraints.emplace_back(); };
	}
	else
	{
		keyword = "LineID";
		emplace_constraint = []() { return &mm.line_constraints.emplace_back(); };
	}


	while (true)
	{
		// Searches for keyword
		aux_read::TryCommentAndContinue(s_inp, readed);
		if (readed != keyword)
			break;

		obj = emplace_constraint();

		// Constraint data
		s_inp >> obj;
	}


	// All OK while reading
	return true;
}

void IO::ReadStiffnessMatrix(std::string& readed)
{

}
void IO::ReadNodalLoads(std::string& readed)
{

}


//	//Checks if all mandatory blocks were defined
//	if (!mandatory_keywords.empty())
//	{
//		//Initial message
//		std::string w = std::string("\n   + ") + std::to_string(mandatory_keywords.size()) + " mandatory block(s) missed:\n";
//		Log::AddWarning(w);
//
//		//Appends missed mandatory keywords
//		for (const std::string_view& missed_block : mandatory_keywords)
//		{
//			Log::AddWarning(missed_block);
//			Log::AddWarning("\n");
//		}
//		return false;
//	}
//
//
//	//All ok while reading
//	return true;
//}


//Check input data before trying to generate the FE model
bool IO::CheckModel()
{
	/// <summary>
	/// 
	/// Talvez seja interessante criar funções para checar cada caso e colocar tudo em um único loop.
	/// Ficaria mais inteligível e fácil de ampliar - principalmente se essas funções auxiliares forem templates
	/// 
	/// </summary>
	/// 
	/// <returns> booleano q indica se o modelo passou por todas as etapas </returns>


	std::map<std::string_view, std::size_t> n_keywords{
		//Mandatory blocks
		{"Keypoints", mm.keypoint_vector.size()}, {"Lines", mm.line_vector.size()}, {"Vessels", mm.vessel_vector.size()},
		{"SegmentProperties", mm.segment_property_vector.size()}, {"SolSteps", mm.moorsolution.GetStepsVec().size()},
		/*nothing to check:*/{"Environment", 1}, {"Solution", 1},
	};

	//Stream with warning message(s)
	std::stringstream ss;
	
	///
	/// Checks mandatory keywords
	///
	
	/*--- Keypoints ---*/
	if (mm.keypoint_vector.front().GetIDNumber() != 1 || mm.keypoint_vector.back().GetIDNumber() != n_keywords["Keypoints"])
		ss << "\n   + Invalid keypoint numbering";
	/*--- Segment properties ---*/
	if (mm.segment_property_vector.front().GetNumber() != 1 || mm.segment_property_vector.back().GetNumber() == n_keywords["SegProp"])
		ss << "\n   + Invalid segment property numbering";
	/*--- Lines ---*/
	if (mm.line_vector.front().GetNumber() != 1 || mm.line_vector.back().GetNumber() != n_keywords["Lines"])
		ss << "\n   + Invalid line numbering";
	{
		std::for_each(mm.line_vector.cbegin(), mm.line_vector.cend(), [&](const Line& line) {
			if (line.GetKeypointA() > n_keywords["Keypoints"] || line.GetKeypointB() > n_keywords["Keypoints"])
				ss << "\n   + Invalid keypoint referenced at line number " << line.GetNumber();
			if (!line.GetSegmentSetOpt())
				std::for_each(line.GetAllSegments().cbegin(), line.GetAllSegments().cend(), [&](const LineSegment& seg) {
				if (seg.GetProperty() > n_keywords["SegmentProperties"])
					ss << "\n   + Invalid segment property referenced at line number " << line.GetNumber(); }
			);//end of nested for_each (segments)
		});//end of first for_each (lines)
	}
	/*--- Vessels ---*/
	if (mm.vessel_vector.front().GetNumber() != 1 || mm.vessel_vector.back().GetNumber() != n_keywords["Vessels"])
		ss << "\n   + Invalid vessel numbering";
	{
		std::for_each(mm.vessel_vector.cbegin(), mm.vessel_vector.cend(), [&](const Vessel& vessel) {
			if (vessel.GetKeypoint() > n_keywords["Keypoints"])
				ss << "\n   + Invalid pilot node referenced at vessel number " << vessel.GetNumber(); }
		);//end of for_each
	}
	if (mm.moorsolution.GetStepsVec().front().GetNumber() != 1 || mm.moorsolution.GetStepsVec().back().GetNumber() != n_keywords["SolSteps"])
		ss << "\n   + Invalid solution steps numbering";
	
	/// 
	/// Checks optional keywords
	/// 
	
	/*--- Segment sets ---*/
	if (!mm.segment_set_vector.empty())
	{
		std::for_each(mm.segment_set_vector.cbegin(), mm.segment_set_vector.cend(), [&](const SegmentSet& set) {
			std::for_each(set.GetAllSegment().cbegin(), set.GetAllSegment().cend(), [&](const LineSegment& seg) {
				if (seg.GetProperty() > n_keywords["Keypoints"])
					ss << "\n   + Invalid segment property referenced at segment set number " << set.GetIDNumber();
			});//end of nested for_each (line segments)
		});//end of first for_each (segment set)
	}
	/*--- Vessel displacements ---*/
	if (!mm.vessel_disp_vector.empty())
	{
		std::for_each(mm.vessel_disp_vector.cbegin(), mm.vessel_disp_vector.cend(), [&](const VesselDisplacement& disp) {
			if (disp.GetVesselID() > n_keywords["Vessels"]) 
				ss << "\n   + Invalid vessel ID to apply displacement: " << disp.GetVesselID() ;
			if (disp.GetStep() > n_keywords["SolSteps"] )
				ss << "\n   + Invalid analysis step number to displace the vessel number " << disp.GetVesselID() << ": " << disp.GetStep();
		});//end for (vessel displacements)
	}
	/*--- Platforms ---*/
	if (!mm.moorpost.GetAllPlatformCADs().empty())
	{
		std::for_each(mm.moorpost.GetAllPlatformCADs().cbegin(), mm.moorpost.GetAllPlatformCADs().cend(), [&](const CADData& c) {
			if (c.GetNumber() > n_keywords["Vessels"]) 
				ss << "\n   + \"" << c.GetNumber() << "\" is not a valid vessel ID to link a CAD file";
		});
	}
	/*--- Displacement fields ---*/
	if (!mm.disp_field_vector.empty())
	{
		std::for_each(mm.disp_field_vector.cbegin(), mm.disp_field_vector.cend(), [&](const LineDisplacementField& disp) {
			if (disp.GetNumber() > n_keywords["Lines"]) 
				ss << "\n   + Invalid line ID to apply displacement field: " << disp.GetNumber();
			if (disp.GetStep() > n_keywords["SolSteps"])
				ss << "\n   + Invalid analysis step number to displace the vessel number " << disp.GetNumber() << ": " << disp.GetStep();
		});//end for (displacement fields)
	}
	/*--- Loads ---*/
	if (!mm.moorload_vector.empty())
	{
		std::for_each(mm.moorload_vector.cbegin(), mm.moorload_vector.cend(), [&](const MoorLoad& load) {
			//Description
			auto description = load.GetDescription();
			
			//Check vessel number
			if (description == "vessel")
			{
				if ( load.GetNodeID() > n_keywords["Vessels"] )
					ss << "\n   + Invalid vessel number to apply load: " << load.GetNodeID(); 
			}
			else 
			{ 
				//Check line number
				if (load.GetLineID() > n_keywords["Lines"])
					ss << "\n   + Invalid line number to apply load: " << load.GetLineID();
				if (size_t seg = load.GetSegmentID())
				{
					//With segment defined (not using SegmentSet)
					if (mm.line_vector[load.GetLineID() - 1].GetNSegments() > 0 && seg > n_keywords["SegmentProperties"])
						ss << "\n   + Invalid segment number to apply load: " << load.GetNodeID() << " at line number " << load.GetLineID();
					//Seg == 0 -> use SegmentSet 
					else
					{
						// No segment set: 
						if (mm.segment_set_vector.empty())
							ss << "\n   + Invalid segment number to apply load at line number " << load.GetLineID() << ":  no SegmentSet defined";
						else
						{ // Check segment set
							size_t segset_size = mm.segment_set_vector[mm.line_vector[load.GetLineID() - 1].GetSegmentSet() - 1].GetSegmentSetSize();
							if (seg > segset_size)
							{
								ss << "\n   + Invalid segment number to apply load at line number " << load.GetLineID() << ": segment number " <<
									seg << " is not defined at SegmentSet number " << mm.line_vector[load.GetLineID() - 1].GetSegmentSet();
							}
						}
					}// end 'seg == 0'
				}
			} // end 'else vessel'

		});//end for (loads)
	}
	/*--- Constraints ---*/
	{
		//MoorConstraint* constrPtr = &mm.moor_constraint; //pointer to MoorConstraint
		//if (constrPtr->ExistAnchorConstraint())
		//{
		//	std::for_each(constrPtr->GetAnchorConstraints().cbegin(), constrPtr->GetAnchorConstraints().cend(), [&](const AnchorConstraint& c) {
		//		if (c.GetNumberID() > n_keywords["Lines"])
		//			ss << "\n   + \"" << c.GetNumberID() << "\" is not a valid line ID to change its anchor constraint";
		//		});
		//}
		//if (constrPtr->ExistVesselConstraint())
		//{
		//	std::for_each(constrPtr->GetVesselConstraints().cbegin(), constrPtr->GetVesselConstraints().cend(), [&](const VesselConstraint& c) {
		//		if (c.GetNumberID() > n_keywords["Vessels"])
		//			ss << "\n   + \"" << c.GetNumberID() << "\" is not a valid vessel ID to change its constraints";
		//		});
		//}
		//if (constrPtr->ExistLineConstraint())
		//{
		//	std::for_each(constrPtr->GetLineConstraints().cbegin(), constrPtr->GetLineConstraints().cend(), [&](const LineConstraint& c) {
		//		if (c.GetNumberID() > n_keywords["Lines"])
		//			ss << "\n   + \"" << c.GetNumberID() << "\" is not a valid line ID to change its constraints";
		//		});
		//}
	}

	// Checking status
	bool modelOk = true;

	/// Approach for check empty stringstream adapted from 
	/// https://stackoverflow.com/questions/8046357/how-do-i-check-if-a-stringstream-variable-is-empty-null/36327567
	if (ss.peek() != decltype(ss)::traits_type::eof())
	{
		Log::AddWarning(ss);
		modelOk = false;
	}


	return modelOk;
}

//Writes Giraffe model file
void IO::WriteGiraffeModelFile()
{
	//Giraffe input file
	std::ofstream fgir(folder_name + input_name + ".inp", std::ofstream::out);

	fgir << "/////////////////////////////////////////////////////////////////////////////\n";
	fgir << "//                                                                         //\n";
	fgir << "//   GIRAFFE input file generated automatically by GIRAFFEMoor v" << version << " //\n";
	fgir << "//                                                                         //\n";
	fgir << "/////////////////////////////////////////////////////////////////////////////\n\n";

	fgir << "\n/*Units:\n\tTime: s\n\tMass: kg\n\tLinear: m\n\tForce: N\n\tRotation: rad\n\tAzimuth: degree\n*/\n";

	//General formatting
	fgir.setf(std::ofstream::scientific);	//Use scientific notation to float points
	fgir << std::setprecision(8);			//Default precision for float points

	fgir << "\nSolutionSteps\t" << gm.solution_vector.size() << "\n";
	for (const Solution* sol : gm.solution_vector )
		sol->WriteGiraffeModelFile(fgir);

	fgir << "\nMonitor\n";
	gm.monitor.WriteGiraffeModelFile(fgir);

	fgir << "\nPostFiles\n";
	gm.post.WriteGiraffeModelFile(fgir);

	fgir << "\nSolverOptions\n";
	gm.gir_solver.WriteGiraffeModelFile(fgir);

	fgir << "\nConvergenceCriteria\n" << gm.gir_solver.GetConvCriteria();

	/************************
	 * SORT NODE SET VECTOR *
	 ************************/
	std::sort(gm.node_set_vector.begin(), gm.node_set_vector.end());

	fgir << "\nNodeSets\t" << gm.node_set_vector.size() << "\n";
	for (NodeSet& ns : gm.node_set_vector )
		ns.WriteGiraffeModelFile(fgir);

	fgir << "\nPipeSections\t" << gm.pipe_section_vector.size() << "\n";
	for (const PipeSection& ps : gm.pipe_section_vector )
		ps.WriteGiraffeModelFile(fgir);

	fgir << "\nRigidBodyData\t" << gm.rbdata_vector.size();
	for ( const RigidBodyData& rbdata : gm.rbdata_vector )
		rbdata.WriteGiraffeModelFile(fgir);
	fgir << "\n";

	if ( !gm.post.GetAllCADs().empty() )
	{
		fgir << "\nCADData\t" << gm.post.GetAllCADs().size() << "\n";
		for (const CADData& cad : gm.post.GetAllCADs())
			cad.WriteGiraffeModelFile(fgir);
	}

	fgir << "\nConstraints\t" << gm.constraint_vector.size() << "\n";
	for (const Constraint* constraint : gm.constraint_vector )
		constraint->WriteGiraffeModelFile(fgir);

	fgir << "\nEnvironment\n";
	gm.environment.WriteGiraffeModelFile(fgir);

	fgir << "\nContacts\t" << gm.contact_vector.size() << "\n";
	for (const Contact* cont : gm.contact_vector )
		cont->WriteGiraffeModelFile(fgir);

	fgir << "\nSurfaces\t" << gm.oscillatory_vector.size() << "\n";
	for (const OscillatorySurf& osc_surf : gm.oscillatory_vector )
		osc_surf.WriteGiraffeModelFile(fgir);

	fgir << "\nSurfaceSets\t" << gm.surface_set_vector.size() << "\n";
	for (const SurfaceSet& surf_set : gm.surface_set_vector )
		surf_set.WriteGiraffeModelFile(fgir);

	fgir << "\nCoordinateSystems\t" << gm.cs_vector.size() << "\n";
	for (const CoordinateSystem& cood_sys : gm.cs_vector )
		cood_sys.WriteGiraffeModelFile(fgir);

	fgir << "\nSpecialConstraints\t" << gm.special_constraint_vector.size() << "\n";
	for (const SpecialConstraint* spec_constr : gm.special_constraint_vector )
		spec_constr->WriteGiraffeModelFile(fgir);

	fgir << "\nElements\t" << gm.element_vector.size() << "\n";
	for (const Element* element : gm.element_vector )
		element->WriteGiraffeModelFile(fgir);

	fgir << "\nNodes\t" << gm.node_vector.size() << "\n";
	for (const Node& node : gm.node_vector )
		node.WriteGiraffeModelFile(fgir);

	//Chenge precision for displacements and loads
	fgir << std::setprecision( 16 );

	fgir << "\nDisplacements\t" << gm.displacement_vector.size() << "\n";
	for (const Displacement* disp : gm.displacement_vector )
		disp->WriteGiraffeModelFile(fgir);

	if ( !gm.load_vector.empty() )
	{
		fgir << "\nLoads\t" << gm.load_vector.size() << "\n";
		for (const Load* load : gm.load_vector )
			load->WriteGiraffeModelFile(fgir);
	}

	fgir.close();
}
